#!/bin/bash

# +--------------------------------------------------------------------+
# | This Source Code Form is subject to the terms of the Mozilla       |
# | Public License, v. 2.0. If a copy of the MPL was not distributed   |
# | with this file, You can obtain one at http://mozilla.org/MPL/2.0/. |
# +--------------------------------------------------------------------+
#        email: Andrey Makarov <mka-at-mailru@mail.ru>
# Project home: https://github.com/loafer-mka/version-stamper.git
#
#               Copyright (c) Andrey Makarov 2023
#
# check presence of utilities
#
function DIE
{
	local	RES=$1
	shift
	echo -e "ERROR: $*" >&2
	exit $RES
}
type -p awk >/dev/null || DIE 100 "The 'awk' must be installed and available from script"
type -p cat >/dev/null || DIE 100 "The 'cat' must be installed and available from script"
type -p chmod >/dev/null || DIE 100 "The 'chmod' must be installed and available from script"
type -p cut >/dev/null || DIE 100 "The 'cut' must be installed and available from script"
type -p date >/dev/null || DIE 100 "The 'date' must be installed and available from script"
type -p git >/dev/null || DIE 100 "The 'git' must be installed and available from script"
type -p ls >/dev/null || DIE 100 "The 'ls' must be installed and available from script"
type -p mkdir >/dev/null || DIE 100 "The 'mkdir' must be installed and available from script"
type -p realpath >/dev/null || DIE 100 "The 'realpath' must be installed and available from script"
type -p rm >/dev/null || DIE 100 "The 'rm' must be installed and available from script"
type -p sed >/dev/null || DIE 100 "The 'sed' must be installed and available from script"
type -p sleep >/dev/null || DIE 100 "The 'sleep' must be installed and available from script"
type -p which >/dev/null || DIE 100 "The 'which' must be installed and available from script"
type -p xargs >/dev/null || DIE 100 "The 'xargs' must be installed and available from script"
STAMPER_DOS2UNIX="$(type -p dos2unix 2>/dev/null)"
STAMPER_UNIX2DOS="$(type -p unix2dos 2>/dev/null)"
if [[ "Windows_NT" == ${OS} ]]; then
	[[ -n ${STAMPER_DOS2UNIX} ]] || DIE 100 "The 'dos2unix' must be installed and available from script"
	[[ -n ${STAMPER_UNIX2DOS} ]] || DIE 100 "The 'unix2dos' must be installed and available from script"
	# posix utilities need in linux-style EOLs (lf), so we will transfer all files via dos2unix.
	# under windows this is mandatry; under linux we will do same because some source files may have crlf EOLs
else
	type -p whoami >/dev/null || DIE 100 "The 'whoami' must be installed and available from script"
	type -p ps >/dev/null || DIE 100 "The 'ps' must be installed and available from script"
fi

STAMPER_SCRIPT_PATH="$(readlink -f -- "$0")"

# disable history support; this enables 'echo "foo!"' (this sample with enabled history produces 'bash: !: event not found')
set +H
# disable monitor
set +m
# last function/builtin in pipe will run in current shell
shopt -s lastpipe
# use extended glob syntax by ${foo#...} and ${foo%...} expansions
shopt -s extglob
# use aliases (to allow __VERBOSE__ switching)
shopt -s expand_aliases

source ${STAMPER_SCRIPT_PATH%/*}/stdpath

if [[ "Windows_NT" == ${OS} ]]; then
	__STDPATH_FUNCTION__  --var STAMPER_SCRIPT_PATH  --mixed  "${STAMPER_SCRIPT_PATH}"
fi

# load stamper's version information
if [[ "0" -ne $(grep --count "<<<<<<" "${STAMPER_SCRIPT_PATH}-this") ]]; then
	set -o allexport
	source <(awk -v RS='(\r\n|\n\r|\r|\n)' '
		BEGIN{ mode = 0; }
		mode == 0 && /^\s*<<<<<<*\s/   { mode = 1; next; }
		mode == 1 && ( /^\s*======*\s*$/ || /^\s*\|\|\|\|\|\|*\s*$/) { mode = 2; next; }
		mode == 2 && /^\s*>>>>>>*\s/   { mode = 0; next; }
		mode <= 1 { print; }
	' "${STAMPER_SCRIPT_PATH}-this")
	set +o allexport
else
	source "${STAMPER_SCRIPT_PATH}-this"
fi

export STAMPER_SUITE="Version stamper suite ${STAMPER_VERSION_TEXT}"
# note: the STAMPER_SUITE is a signature of script; setup will detect it as part of version suite using given text

# title for echoing somewere
STAMPER_SCRIPT_NAME="${STAMPER_SCRIPT_PATH##*/}"
STAMPER_SUITE_TITLE="The ${STAMPER_SUITE}. ${STAMPER_VERSION_DECLARATION}\nVersion files generator \"${STAMPER_SCRIPT_NAME}\""

#
# Split arg parsing in two passes: a) preliminary now; b) rest of options
# and plugin commands after loading configuration and getting all properties
# and version data.
# NOTE: the argument --directory changes current folder and results of
# 'git rev-parse --is-bare-repo', 'git rev-parse --show-toplevel' also
# may be changed. So check for repo type, folders, read configuration
# _after_ preliminary command line parsing;
#

#
# preliminary arguments' parsing
#
STAMPER_CURRENT_DIR=""
STAMPER_USE_DEFAULT_CMD="true"
STAMPER_VERBOSE=""		# empty value means "not set"
ref=""
((an=0))
for a in "$@"; do
	((an++))
	if [ -n "$ref" ]; then
		printf -v "$ref" '%s' "$a"
		ref=""
	else
		case "$a" in
		-V | --version)
			echo "${STAMPER_VERSION_TEXT}"
			exit 0
			;;
		--directory=*)
			STAMPER_CURRENT_DIR=${a:12}
			;;
		-cd=*)
			STAMPER_CURRENT_DIR=${a:4}
			;;
		-cd | --directory)
			[[ ${#@} -gt $an ]] || DIE 2 "working directory must be given after $a"
			ref="STAMPER_CURRENT_DIR"
			;;
		-v | --verbose)
			[[ -z ${STAMPER_VERBOSE} ]] && STAMPER_VERBOSE="simple" || STAMPER_VERBOSE="extended"
			;;
		-q | --quit)
			STAMPER_VERBOSE="off"
			;;
		*)
			# other options will be parsed later
			STAMPER_USE_DEFAULT_CMD="false"
			;;
		esac
	fi
done
unset ref
unset an

# path under windows may contain C:/... prefix instead of /c/...  or /cygdrive/c/... or /dev/fs/c/...
# note 1: normal mingw/cygwin/SUA/... absolute path starts with "/"; the '$0' contains path
#         as it was used and it may starts with C:/... if script was executed by windows
#         application
# note 2: cygpath utility defines:
#         - "unix" path as "/c/some/folder/file"
#         - "windows" path as "c:\some\folder\file"
#         - "mixed" path as "c:/some/folder/file"
#         really the cygpath is not mutual property of cygwin, it accomplishes
#         also mingw and msys2 (SFU, SUA, etc were not checked);
#         we may state that mixed path _may_ be used for '$0' and for other
#         purposes in environment that does not support the mixed path format.
#         for example "readlink", "realpath" etc will print unchanged argument
#         if mixed path was used
# note 3: git-for-windows built on mingw/msys2 may return path in _mixed_ format...
# note 4: realpath may return /C/... (capitalized drive letter) if /C/... form was
#         used as input argument; elsewere lowercase drive letter will be used.
#         So we may have two different pathes starting from uppercase or lowercase
#         drive letter; this may mess up nested path detection
#         (i.e. 'realpath --relative-to=parent nested' will return path via root
#         "../../../../C/folder1/folder2/parent/folder4/nested").
#         same shit is for cd/pwd, pushd/popd, realpath, readlink ... :(
#         the only twin (input_path -> windows_path -> unix_path convertion will
#         normalize drive letter case.
# so use own path-normalization script 'stdpath'
if [[ -n ${STAMPER_DOS2UNIX} ]]; then
	function __git_filter_eols__
	{
		git --no-pager "${1}" 2>/dev/null | "${STAMPER_DOS2UNIX}" --quiet 2>/dev/null
	}
	function __cat_filter_eols__
	{
		"${STAMPER_DOS2UNIX}" --quiet <"${VERSION_ROOT_DIR}/${1}" 2>/dev/null
	}
else
	function __git_filter_eols__
	{
		git --no-pager "${1}" 2>/dev/null
	}
	function __cat_filter_eols__
	{
		cat -- "${VERSION_ROOT_DIR}/${1}" 2>/dev/null
	}
fi

#
# check for changed directory
#
if [[ -n ${STAMPER_CURRENT_DIR} ]]; then
#	__normalize_path__  STAMPER_CURRENT_DIR  "${STAMPER_CURRENT_DIR}"
	__STDPATH_FUNCTION__ --var STAMPER_CURRENT_DIR --mixed "${STAMPER_CURRENT_DIR}"
	[[ ! -d "${STAMPER_CURRENT_DIR}" ]] && DIE 1 "Cannot change directory to \"${STAMPER_CURRENT_DIR}\""
	pushd "${STAMPER_CURRENT_DIR}" >/dev/null 2>&1
fi
# now we must be at wanted folder, so we may perform basic checks and load configuration file

#
# restore folder and exit
#   EXIT  exitcode
#
function EXIT
{
	[[ -n "${STAMPER_CURRENT_DIR}" ]] && popd >/dev/null 2>&1
	exit $1
}

#
# print message on stderr and exit with given exit code
#   DIE  exitcode  message
#
unset -f DIE
function DIE
{
	local	RES=$1
	shift
	echo -e "ERROR: $*" >&2
	EXIT $RES
}

#
# detect and check repo type
#
temp="$(git --no-pager rev-parse --is-bare-repository 2>/dev/null)"
# git rev-parse --is-bare-repository
#	it prints 'true' (exitcode=0) if this is bare repo; 'false' (exitcode=0) if it is worktree;
#	nothing on stdout and error message on stderr if current folder is not repo yet (exitcode=128)
temp="${temp:-no-git}"
case "${temp,,}" in
no-git)
	DIE 1 "Use this script in git working tree only."
	;;
true)
	# bare repo are not supported, use in worktree only
	DIE 1 "Use this script in git working tree only, do not apply on bare repository."
	;;
*)
	;;
esac
unset temp

#
# these values _may_ be used later depending on versbose command-line option and configuration settings
STAMPER_TIMESTAMP_UNIT=1000000
STAMPER_TIMESTAMP_START="$(date +"%s%N")"
((STAMPER_TIMESTAMP_START=STAMPER_TIMESTAMP_START/STAMPER_TIMESTAMP_UNIT))
STAMPER_TIMESTAMP_LAST="${STAMPER_TIMESTAMP_START}"

function __VERBOSE_SIMPLE__
{
	echo -e "$*" >&2
}
function __VERBOSE_EXTENDED__
{
	local tnow="$(date +"%s%N")"
	local t0="${STAMPER_TIMESTAMP_START}"
	local tx="${STAMPER_TIMESTAMP_LAST}"
	local tz
	((tnow=tnow/STAMPER_TIMESTAMP_UNIT))
	((t0=tnow-t0))
	((tx=tnow-tx))
	printf -v tz "[%u.%03u (+%u ms)]" $((t0/1000)) $((t0%1000)) $tx
	echo -e "$*\n${tz}" >&2
	STAMPER_TIMESTAMP_LAST="${tnow}"
}
function __VERBOSE_OFF__
{
	:
}
case "${STAMPER_VERBOSE,,}" in
simple | extended | off)
	alias __VERBOSE__=__VERBOSE_${STAMPER_VERBOSE^^}__
	;;
*)
	alias __VERBOSE__=__VERBOSE_OFF__
	;;
esac

#
# load stamper's configuration information
#
[[ -f "${STAMPER_SCRIPT_PATH}-config" ]] || echo "	#
	# this file can be freely modified; it is not part of licensed code
	#

	# default copyright/copyleft to paste into newly created config files
	STAMPER_DEFAULT_DECL=\"Copyright (c)\"
" >"${STAMPER_SCRIPT_PATH}-config"
source "${STAMPER_SCRIPT_PATH}-config" 2>/dev/null

#
# detect main git folders
#
__VERBOSE__ "Detect main folders and git submodule support"
git rev-parse --show-toplevel 2>/dev/null | __STDPATH_FUNCTION__ --var VERSION_ROOT_DIR --mixed
__VERBOSE__ "git rev-parse --show-toplevel\n.   VERSION_ROOT_DIR=\"${VERSION_ROOT_DIR}\""
git rev-parse --absolute-git-dir 2>/dev/null | __STDPATH_FUNCTION__ --var VERSION_GIT_DIR --mixed
__VERBOSE__ "git rev-parse --absolute-git-dir\n.   VERSION_GIT_DIR=\"${VERSION_GIT_DIR}\""
[[ -n ${VERSION_ROOT_DIR} && -n ${VERSION_GIT_DIR} ]] || DIE 1 "Use this script in git working tree, do not apply outside of git repository."
# if STAMPER_CURRENT_DIR was assigned by option, then folder was changed and VERSION_CURRENT_DIR becomes identical
# NOTE: git reports --show-toplevel and --absolute-git-dir after resolving symlinks, so
# we must use realpath to get resolved path too and then filter it manually to normal form
VERSION_CURRENT_DIR="$(pwd 2>/dev/null)"
if [[ ${OS} == "Windows_NT" ]]; then
	case "${VERSION_CURRENT_DIR,,}" in
	/cygdrive/?/*)
		STAMPER_PATH_TYPE="cygwin"
		;;
	/dev/fs/?/*)
		STAMPER_PATH_TYPE="sua"
		;;
	/?/*)
		STAMPER_PATH_TYPE="msys"
		;;
	*)
		for temp in /usr/bin/msys-[0-9]*.dll /usr/bin/cygwin[0-9]*.dll /bin/msys-[0-9]*.dll /bin/cygwin[0-9]*.dll; do
			case "${temp,,}" in
			*bin/msys-[0-9]*)
				STAMPER_PATH_TYPE="msys"
				break
				;;
			*bin/cygwin[0-9]*)
				STAMPER_PATH_TYPE="cygwin"
				break
				;;
			esac
		done
		[[ -z ${STAMPER_PATH_TYPE} ]] && STAMPER_PATH_TYPE="unix"
		;;
	esac
else
	STAMPER_PATH_TYPE="unix"
fi
__STDPATH_FUNCTION__ --var VERSION_CURRENT_DIR --mixed -- "$(realpath -m -- "${VERSION_CURRENT_DIR}" 2>/dev/null)"
__VERBOSE__ "realpath -m -- \"\$(pwd)\"\n.   VERSION_CURRENT_DIR=\"${VERSION_CURRENT_DIR}\"\n.   STAMPER_PATH_TYPE=\"${STAMPER_PATH_TYPE}\""

VERSION_HOOKS_DIR=""
function __detect_hooks_dir__
{
	# VERSION_GIT_DIR may now points to actual .git directory with full content
	# or to reduced .git directory of worktree with only HEAD, config, logs/ ...
	# so hooks/ subfolder must be detected in main .git directory
	VERSION_HOOKS_DIR="${VERSION_GIT_DIR}/hooks"
	if [[ -d ${VERSION_HOOKS_DIR} ]]; then
		__VERBOSE__ "$1.   VERSION_HOOKS_DIR=\"${VERSION_HOOKS_DIR}\""
	else
		git rev-parse --git-common-dir 2>/dev/null |__STDPATH_FUNCTION__ --var VERSION_HOOKS_DIR --mixed
		__VERBOSE__ "$1git rev-parse --git-common-dir\n$1.   VERSION_HOOKS_DIR=\"${VERSION_HOOKS_DIR}\""
	fi
	[[ -d ${VERSION_HOOKS_DIR} ]] || VERSION_HOOKS_DIR=""
}
__detect_hooks_dir__ ""

VERSION_SUBMOD_NAME=""
VERSION_SUBMOD_PATH=""
git rev-parse --show-superproject-working-tree 2>/dev/null |__STDPATH_FUNCTION__ --var VERSION_SUPER_DIR --mixed
__VERBOSE__ "git rev-parse --show-superproject-working-tree\n.   VERSION_SUPER_DIR=\"${VERSION_SUPER_DIR}\""
if [[ -z ${VERSION_SUPER_DIR} ]]; then
	# we are out of submodule  OR  we are inside not initialized submodule
	# in second case VERSION_ROOT_DIR and VERSION_GIT_DIR both are pointing to superproject folders
	if [[ -e ${VERSION_ROOT_DIR}/.gitmodules ]]; then
		# submodules exists  AND  this submodule was not initialized
		VERSION_SUPER_DIR="${VERSION_ROOT_DIR}"
		VERSION_SUBMOD_OK="false"
		__VERBOSE__ ".   = submodule MAY BE USED BUT NOT UPDATED YET"
	else
		# no submodules yet
		VERSION_SUBMOD_OK="none"
		__VERBOSE__ ".   = no submodule support"
	fi
else
	# we are inside submodule
	VERSION_SUBMOD_OK="true"
	__VERBOSE__ ".   = submodule used"
fi
if [[ -n ${VERSION_SUPER_DIR} ]]; then
	# determine submodule name and path
	__VERBOSE__ ".   Scan submodules\n.   git config --file=\"${VERSION_SUPER_DIR}/.gitmodules\" --null --get-regexp 'submodule\..*\.path'"
	# note: under windows may exist few unix-like nvironment at once; you may run some cygwin shell for example and call
	# git-for-windows based on msys2, so full pathes in shell may mismatch with pathes used ny git
	# (for example: /cygdrive/c/temp/test/.gitmodules vs /c/temp/test/.gitmodules)
	# so do not use full pathes for git, use relative only; change current directory before run git.
	pushd "${VERSION_SUPER_DIR}" >/dev/null 2>&1
	git --no-pager config --file="./.gitmodules" --null --get-regexp 'submodule\..*\.path' 2>/dev/null \
	| while IFS=$'\n' read -d $'\0' modname moddir ; do
		modname="${modname#submodule.}"
		modname="${modname%.path}"
		modpath="${VERSION_SUPER_DIR}/${moddir}"
		temp="${VERSION_CURRENT_DIR}"
		if [[ ${OS} == "Windows_NT" ]]; then
			modpath="${modpath,,}"
			temp="${temp,,}"
		fi
		__VERBOSE__ ".   .   '${modname}' at folder '${moddir}' full path '${modpath}'"
		if [[ ${modpath} == ${temp} || ${modpath}/ == ${temp:0:${#modpath}+1} ]]; then
			# current folder is submodule folder or nested in ...
			VERSION_SUBMOD_NAME="${modname}"
			VERSION_SUBMOD_PATH="${moddir}"
			__VERBOSE__ ".   .   = yes, we are at submodule path\n.   .   VERSION_SUBMOD_NAME=\"${modname}\"\n.   .   VERSION_SUBMOD_PATH=\"${moddir}\""
			# initialize+update it if not done; this will create .git/modules/... hierarchy, so VERSION_GIT_DIR may be set to actual location
			if [[ "false" == ${VERSION_SUBMOD_OK} ]]; then
				__VERBOSE__ ".   .   submodule was not updated yet, try do that\n.   .   git submodule update --init --force --recursive -- \"${modpath}\""
				git submodule update --init --force --recursive -- "${moddir}" 1>&2
				[[ 0 -ne $? ]] && DIE 4 "Cannot initialize submodule '${modname}' at '${moddir}'"
				pushd "${modpath}" >/dev/null 2>&1
				git  rev-parse --absolute-git-dir 2>/dev/null |__STDPATH_FUNCTION__ --var VERSION_GIT_DIR --mixed
				__VERBOSE__ ".   .   git rev-parse --absolute-git-dir\n.   .   .   VERSION_GIT_DIR=\"${VERSION_GIT_DIR}\""
				VERSION_ROOT_DIR="${modpath}"
				__VERBOSE__ ".   .   change worktree directory\n.   .   .   VERSION_ROOT_DIR=\"${VERSION_ROOT_DIR}\""
				__detect_hooks_dir__ ".   .   "
				popd >/dev/null 2>&1
			fi
			break
		fi
		unset modname moddir modpath temp
	done
	popd >/dev/null 2>&1
fi
unset VERSION_SUBMOD_OK
#
# ok, we known root of working tree, so load configuration now
#

#
# strip leading ./ and / symbols, so we get correct working_tree_relative_file_path
#   __normalize_local_path__  varname  filename
#
function __normalize_local_path__
{
	local    __normalize_local_path__filename
	declare -g "${1}"

	__normalize_local_path__filename="${2//\\//}"
	printf -v "${1}" '%s' "${__normalize_local_path__filename/#+(.\/|\/)/}"
}

#
# read file (! check for merge errors !) and echo it using LF eols
#   __READ_LF__ filename
#
function __READ_LF__
{
	local	merge_status
	local	awk_script
	local	file

	# note 1: always pass via dos2unix on reading from FS under windows because filters (sed, awk etc.) are eol-sensetive
	case "${1}" in
	/* | ?:/*)
		# abs path out of tree (note: mixed and widnows forms must be excluded by the caller logic
		case "${STAMPER_VERBOSE,,}" in
		simple | extended)
			# avoid complex string expansion using subshell execution if result is unused
			__VERBOSE__ "$([ -n "${STAMPER_DOS2UNIX}" ] && echo "dos2unix" || echo "cat") \"$1\"\n.   ... (external file)"
			;;
		esac
		[[ -n ${STAMPER_DOS2UNIX} ]] && "${STAMPER_DOS2UNIX}" --quiet 2>/dev/null <"$1" || cat -- "$1" 2>/dev/null
		;;
	*)
		file="$1"
		# note 2: the file on FS may be corrupted due to merge collisions; try to resolve them when detected (prefer our before their)
		# note 3: pathspec has special "magic signatures" (see 'man gitglossary' for more informatin)
		#         magic signature :/: means "from top of repository"
		#         (!) if you are use this magic AND start path with "./" prefix then 'git status' will interpret existing and controlled files as untracked
		#         git status ... -- :/:./controlled-filename           will return "?? ./controlled-filename" for unchanged 'controlled-filename' (changed too)
		#         git status ... -- :/:controlled-filename             will return "" for unchanged 'controlled-filename'
		#         git status ... -- controlled-filename                will return "" for unchanged 'controlled-filename'
		merge_status="$(git --no-pager status --porcelain  --untracked-files=normal --ignored -- ":/:${file}")"
		__VERBOSE__ "git status --porcelain --untracked-files=normal --ignored -- \":/:${file}\"\n.   status=\"$merge_status\""
		# really <<<<<<, ======, >>>>>> are bigger than in script below
		awk_script='
			BEGIN{ mode = 1; }
			mode == 1 && /^\s*<<<<<<*\s/   { mode = 2; next; }
			mode == 2 && /^\s*======*\s*$/ { mode = 4; next; }
			mode == 2 && /^\s*\|\|\|\|\|\|*\s*$/ { mode = 8; next; }
			mode == 8 && /^\s*======*\s*$/ { mode = 4; next; }
			mode == 4 && /^\s*>>>>>>*\s/   { mode = 1; next; }
			0 != and( mode, F )            { print; }
		'

		case "$merge_status" in
		"UU "* | "AA "* | "AU "* | "UA "*)
			# UU	unmerged, both modified
			# AA	unmerged, both added
			# AU	unmerged, added by us
			# UA	unmerged, added by them
				# 1) to use our/their file at once:
				#	git checkout --ours|--theirs -- "filename"
				#
				# 2) to use merged file with preference of our/their in conflicted areas (normally merged other areas):
				#	git show :1:"filename" >tmp.base
				#	git show :2:"filename" >tmp.our
				#	git show :3:"filename" >tmp.their
				#	git merge-file --ours --stdout tmp.our tmp.base tmp.their >"filename"
				#	rm tmp.base tmp.our tmp.their
				#
				# 3) alternative way to build combined file with our/their preference for collisions
				#	is to use merged with collisions file and filter wanted parts by our script
			if [[ -f ${VERSION_ROOT_DIR}/${file} ]]; then
				__VERBOSE__ "__cat_filter_eols__ -- \"${VERSION_ROOT_DIR}/${file}\" |awk -v F=3 \"...\"\n.   ..."
				__cat_filter_eols__ "${file}" |awk -v F=3 -v RS='(\r\n|\n\r|\r|\n)' "$awk_script"
			else
				__VERBOSE__ "The \"${VERSION_ROOT_DIR}/${file}\" is not found"
				# unmerged, deleted by them
				__VERBOSE__ "__git_filter_eols__ show -- \":1:${file}\" |awk -v F=3 \"...\"\n.   ..."
				__git_filter_eols__ show -- ":1:${file}" |awk -v F=3 -v RS='(\r\n|\n\r|\r|\n)' "$awk_script"
			fi
			;;
		"UD "*)
			# unmerged, deleted by them
			__VERBOSE__ "__git_filter_eols__ show -- \":2:${file}\"\n.   ..."
			__git_filter_eols__ show -- ":2:${file}"
			;;
		"DU "*)
			# unmerged, deleted by us
			__VERBOSE__ "__git_filter_eols__ show -- \":3:${file}\"\n.   ..."
			__git_filter_eols__ show -- ":3:${file}"
			;;
		"DD "*)
			# unmerged, both deleted		??? conflict?
			__VERBOSE__ "The \"${VERSION_ROOT_DIR}/${file}\" file was deleted on both merge sides; assume empty"
			;;
		M?" "* | ?M" "*)
			# on some commit hook (pre-commit, commit-msg, post-commit) conflicted files may become 'modified' after adding in stagged area
			# in this case they may have '<<<...===...>>>' insertions
			if [[ -f ${VERSION_ROOT_DIR}/${file} ]]; then
				__VERBOSE__ "__cat_filter_eols__ -- \"${VERSION_ROOT_DIR}/${file}\" |awk -v F=3 \"...\"\n.   ..."
				__cat_filter_eols__ "${file}" |awk -v F=3 -v RS='(\r\n|\n\r|\r|\n)' "$awk_script"
			else
				__VERBOSE__ "The \"${VERSION_ROOT_DIR}/${file}\" is not found in worktree"
			fi
			;;
		*)
			# empty or some other
			if [[ -f ${VERSION_ROOT_DIR}/${file} ]]; then
				__VERBOSE__ "__cat_filter_eols__ -- \"${VERSION_ROOT_DIR}/${file}\"\n.   ..."
				__cat_filter_eols__ "${file}"
			else
				__VERBOSE__ "The \"${VERSION_ROOT_DIR}/${file}\" is not found"
			fi
			;;
		esac
		;;
	esac
}

# __STORE_LF__  worktree_relative_filename   text
function __STORE_LF__
{
	local path="${VERSION_ROOT_DIR}/$1"

	case "$1" in
	//- | //--)
		# stdout or stdin->stdout
		cat
		;;
	/* | ?:/*)
		path="$1"
		;&			# FALL THROUGH
	*)
		local dir="${path%/*}"
		[[ -d ${dir} ]] || mkdir --parents -- "${dir}" 1>&2
		# we assume LF-eols in text string
		cat >"${path}"
		;;
	esac
}
# __STORE_CRLF__  worktree_relative_filename   text
function __STORE_CRLF__
{
	local path="${VERSION_ROOT_DIR}/$1"

	case "$1" in
	//- | //--)
		# stdout or stdin->stdout
		"$STAMPER_UNIX2DOS" --quiet
		;;
	/* | ?:/*)
		path="$1"
		;&			# FALL THROUGH
	*)
		local dir="${path%/*}"
		[[ -d ${dir} ]] || mkdir --parents -- "${dir}" 1>&2
		# we assume LF-eols in text string
		"$STAMPER_UNIX2DOS" --quiet >"${path}"
		;;
	esac
}
if [[ "Windows_NT" == ${OS} ]]; then
	# __STORE_NATIVE_EOL__  worktree_relative_filename   text
	function __STORE_NATIVE_EOL__
	{
		local path="${VERSION_ROOT_DIR}/$1"

		case "$1" in
		//- | //--)
			# stdout or stdin->stdout
			"$STAMPER_UNIX2DOS" --quiet
			;;
		/* | ?:/*)
			path="$1"
			;&			# FALL THROUGH
		*)
			local dir="${path%/*}"
			[[ -d ${dir} ]] || mkdir --parents -- "${dir}" 1>&2
			# we assume LF-eols in text string
			"$STAMPER_UNIX2DOS" --quiet >"${path}"
			;;
		esac
	}
	# __CHMOD__ mode path
	function __CHMOD__
	{
		case "${STAMPER_PATH_TYPE}" in
		msys)
			# assume unsupported operation, msys's chmod does nothing
			[[ "extended" == ${STAMPER_VERBOSE,,} ]] && __VERBOSE__ ".   skip 'chmod \"${1}\" \"${2}\"' -- assume unsupported operation"
			;;
		*)
			# Cygwin or SFU/SUA: they support chmod but may store file
			# permissions in wrong order (cygwin) or implement subset
			# of available 'rwxrwxrwx' modes
			local mode="${1}"
			case "${mode,,}" in
			a+x)
				mode="770"
				;;
			a-x)
				mode="660"
				;;
			a*)
				mode="ug${1:1}"
				;;
			esac
			[[ "extended" == ${STAMPER_VERBOSE,,} ]] && __VERBOSE__ ".   chmod \"${mode}\" -- \"${2}\""
			chmod "${mode}" -- "${2}"
			;;
		esac
	}
else
	# __STORE_NATIVE_EOL__  worktree_relative_filename   text
	function __STORE_NATIVE_EOL__
	{
		local path="${VERSION_ROOT_DIR}/$1"

		case "$1" in
		//- | //--)
			# stdout or stdin->stdout
			cat
			;;
		/* | ?:/*)
			path="$1"
			;&			# FALL THROUGH
		*)
			local dir="${path%/*}"
			[[ -d ${dir} ]] || mkdir --parents -- "${dir}" 1>&2
			# we assume LF-eols in text string
			cat >"${path}"
			;;
		esac
	}
	# __CHMOD__ mode path
	function __CHMOD__
	{
		[[ "extended" == ${STAMPER_VERBOSE,,} ]] && __VERBOSE__ ".   chmod \"${1}\" -- \"${2}\""
		chmod "${1}" -- "${2}"
	}
fi

#
# Translate path to use inside regex
#
# value encoded for substitution into awk's block regexp 
# /block-regexp/ { ... }
function __AS_REGEX_IN__
{
	local arg
	local var="${1}"
	declare -g ${var}
	shift
	arg="${@// /\\\\\\ }"
	arg="${arg//\//\\\/}"
	arg="${arg//./\\.}"
	printf -v "${var}" "${arg}"
}
#
# value encoded for substitution into right part of "sed --regexp-extended 's/.../right-part/'"
function __AS_REGEX_OUT__
{
	local arg
	local var="${1}"
	declare -g ${var}
	shift
	arg="${@//\\/\\\\\\\\}"
	arg="${arg//\//\\\/}"
	arg="${arg//&/\\&}"
	printf -v "${var}" "${arg}"
}
#
# var_QUOTED : encoded for substitution into quoted C-style string
# var_RQREG : right part of enquoted 'sed --regexp-extended "s/.../right-part/"'
function __AS_PREPARED_VALUES__
{
	local arg
	local var="${1}"
	declare -g ${var}_QUOTED
	shift
	arg="${@//\\/\\\\\\\\}"
	arg="${arg//\"/\\\\\"}"
	printf -v "${var}_QUOTED" "${arg}"
	arg="${arg//\\/\\\\}"
	arg="${arg//\//\\\/}"
	arg="${arg//&/\\&}"
	printf -v "${var}_RQREG" "${arg}"
}

#
# Print now suite title using command-line verbose arg
#
__VERBOSE__ "\n${STAMPER_SUITE_TITLE}\n"

#
# load available plugins
#
declare -A STAMPER_PLUGINS
__VERBOSE__ "Load available plugins:"
for plugin in "${STAMPER_SCRIPT_PATH}-plugin-"*; do
	source "${plugin}"
	temp="${plugin##*/${STAMPER_SCRIPT_NAME}-plugin-}"
	__VERBOSE__ ".   $temp: $plugin"
	if [[ \
	       "function" == $(type -t "__PLUGIN_${temp}_NOTICE__") \
		&& "function" == $(type -t "__PLUGIN_${temp}_SAMPLE__") \
		&& "function" == $(type -t "__PLUGIN_${temp}_GETVER__") \
		&& "function" == $(type -t "__PLUGIN_${temp}_CREATE__") \
		&& "function" == $(type -t "__PLUGIN_${temp}_MODIFY__") \
		&& "function" == $(type -t "__PLUGIN_${temp}_ATTRIB__") \
	]]; then
		STAMPER_PLUGINS[${temp}]="${plugin}"
	else
		echo "Warning: bad plugin '${temp}' implementation" 1>&2
	fi
	unset temp
done


#
# parse config file
#
STAMPER_ABBREV_LEN=""
STAMPER_DEFAULT_CMD=""
STAMPER_TEXTOIZE=""
# operations
STAMPER_SETUP_CONFIG="false"
STAMPER_SETUP_HOOKS="false"
STAMPER_GENERATE="false"
STAMPER_DO_LIST_PLUGINS="false"
STAMPER_DO_PRINT_INFO="false"
# list of installed hooks
declare -A STAMPER_HOOKS
# configured plugins
declare -a STAMPER_CONF_PLUGIN
declare -a STAMPER_CONF_TARGET
declare -a STAMPER_CONF_IGNORE
declare -a STAMPER_CONF_ATTRIB
declare -a STAMPER_CONF_LEADER
declare -a STAMPER_CONF_TRAILER
# fill .gitignore and .gitattributes
declare -A STAMPER_FILL_ATTRIB
declare -a STAMPER_FILL_IGNORE
# temp array to check duplicates in target files
declare -A STAMPER_KNOWN_TARGETS

VERSION_LEADER=""
VERSION_TRAILER=""
VERSION_AUTHORSHIP=""
VERSION_DECLARATION=""

VERSION_CONFIG_NAME=".${STAMPER_SCRIPT_NAME}"
if [[ -n ${STAMPER_CURRENT_DIR} ]]; then
	# -cd / --directory option was given
	#
	# NOTE: r/w functions (READ_LF, STORE_LF etc) and git commands use
	# worktree-relative pathes, but -cd option may choose folder inside
	# worktree. We suppose that folder 'like-as-nested-worktree' (i.e.
	# it becomes submodule or subrepo in future or was one in past). So
	# this folder contains own .version-stamper, .gitattributes and
	# .gitignore files; also these files define pathes relative folder
	# given by -cd option. That path differs from worktree-relative path
	# by fixed prefix - relative path of VERSION_CURRENT_DIR inside
	# VERSION_ROOT_DIR.
	# We will change directory to the root of worktree, so pathes in git
	# and in shell commands are same; we must take in account pathes
	# of .gitattributes, .gitignore, and .version-stamper config files
	# and their content.
	VERSION_CONFIG_DIR="${VERSION_CURRENT_DIR}"
	__STDPATH_FUNCTION__ --var VERSION_CONFIG_PREFIX --base "${VERSION_ROOT_DIR}" --mixed -- "${VERSION_CONFIG_DIR}"
	# non-empty VERSION_CONFIG_PREFIX must ends with /, so "${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}"
	# is normal relative pathname ('file', 'dir/file')
	case "${VERSION_CONFIG_PREFIX}" in
	/* | ../* | ?:/*)
		DIE 2 "Wrong target directory \"${STAMPER_CURRENT_DIR}\" outside of repository tree \"${VERSION_ROOT_DIR}\""
		;;
	.)
		# assert VERSION_CURRENT_DIR == VERSION_ROOT_DIR
		VERSION_CONFIG_DIR="${VERSION_ROOT_DIR}"
		VERSION_CONFIG_PREFIX=""
		;;
	*)
		# jump to the root of worktree
		VERSION_CONFIG_PREFIX="${VERSION_CONFIG_PREFIX}/"
		cd "${VERSION_ROOT_DIR}"
		;;
	esac
else
	VERSION_CONFIG_DIR="${VERSION_ROOT_DIR}"
	VERSION_CONFIG_PREFIX=""
fi
VERSION_CONFIG_PATH="${VERSION_CONFIG_DIR}/${VERSION_CONFIG_NAME}"
#
# VERSION_ROOT_DIR - actual worktree root, same as current working dir;
# VERSION_CONFIG_DIR - full path to config folder = VERSION_ROOT_DIR + VERSION_CONFIG_PREFIX
# VERSION_CONFIG_PATH - full path to config file = ( VERSION_ROOT_DIR + VERSION_CONFIG_PREFIX ) + VERSION_CONFIG_NAME
# worktree-relative path to config file is VERSION_CONFIG_PREFIX + VERSION_CONFIG_NAME
# the config folder (VERSION_CONFIG_DIR) has own .gitignore, .gitattributes, .version-stamper files
# the pathes to plugin's target files, gitignored and others are worktree-relative
# note: VERSION_CONFIG_PREFIX is empty or ends with '/', so we may use constructs
# like as "${VERSION_ROOT_DIR}${VERSION_CONFIG_PREFIX}"
#

__VERBOSE__ "\nParsing configuration file \"${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}\"
.   VERSION_CONFIG_PATH=\"${VERSION_CONFIG_PATH}\"
.   VERSION_CONFIG_DIR=\"${VERSION_CONFIG_DIR}\"
.   VERSION_CONFIG_PREFIX=\"${VERSION_CONFIG_PREFIX}\"
.   VERSION_CONFIG_NAME=\"${VERSION_CONFIG_NAME}\""

if [[ -r ${VERSION_CONFIG_PATH} ]]; then
	((cn=0))
	VERSION_CONFIG_MISSING=""
	__READ_LF__ "${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}" | while read -r param value; do
		((cn++))
		param="${param//+([[:space:]])/}"
		value="${value/#+([[:space:]])/}"
		value="${value/%+([[:space:]])/}"
		eval "printf -v 'value' '%s' \"${value}\""
		case "${param,,}" in
		"" | "#"*)
			;;
		abbrev:)
			[[ -z ${STAMPER_ABBREV_LEN} ]] && STAMPER_ABBREV_LEN="$value" || echo "Warning: Ignoring duplicate abbreviation length \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			;;
		leader:)
			[[ -z ${VERSION_LEADER} ]] && VERSION_LEADER="$value" || echo "Warning: Ignoring duplicate leader setting \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			;;
		trailer:)
			[[ -z ${VERSION_TRAILER} ]] && VERSION_TRAILER="$value" || echo "Warning: Ignoring duplicate trailer setting \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			;;
		hooks:)
			if [[ -z ${value} ]]; then
				STAMPER_HOOKS["none"]="true"
			else
				for hook in ${value}; do
					case "${hook}" in
					pre-commit | post-commit | post-checkout | post-rewrite | post-merge | ${STAMPER_SCRIPT_NAME})
						# ${STAMPER_SCRIPT_NAME} is a mark of self-server this stamper project
						STAMPER_HOOKS[${hook,,}]="true"
						;;
					*)
						echo "Warning: Ignoring wrong hook name \"${hook}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
						;;
					esac
				done
			fi
			;;
		verbose:)
			if [[ -z ${STAMPER_VERBOSE} ]]; then 
				case "${value,,}" in
				verbose | true | t | yes | y | ok | set | on | simple | 1)
					STAMPER_VERBOSE="simple"
					;;
				extended | 2)
					STAMPER_VERBOSE="extended"
					;;
				false | f | no | n | none | notset | quiet | clean | off | 0)
					STAMPER_VERBOSE="off"
					;;
				*)
					echo "Warning! undefined verbose mode \"$value\" at ${VERSION_CONFIG_PATH}:$cn (allowed: 'extended', 2; 'true', 't', 'yes', 'y', 'set', 'ok', 'on', 'simple', 1; 'false', 'f', 'no', 'n', 'none', 'notset', 'clean', 'off', 0)" >&2
					STAMPER_VERBOSE="off"
					;;
				esac
				#
				# Print suite header because configuraion file turns on verbose mode while command line does not touch it
				alias __VERBOSE__=__VERBOSE_${STAMPER_VERBOSE^^}__
				[[ "off" != ${STAMPER_VERBOSE,,} ]] && __VERBOSE__ "${STAMPER_SUITE_TITLE}\n"
			else
				# use command-line assigned verbose mode; report this in verbose mode only
				[[ "off" != ${STAMPER_VERBOSE,,} ]] && echo "Warning! ignoring default verbose mode \"$value\" due command line --verbose option at ${VERSION_CONFIG_PATH}:$cn" >&2
			fi
			;;
		plugin-*:)
			temp_plugin="${param#plugin-}"
			temp_plugin="${temp_plugin%:}"
			temp_ignore="false"
			temp_attrib="false"
			temp_leader=""
			temp_trailer=""
			while true; do
				# note: below " ", "	" holds space or tab while [ 	] holds space and tab
				case "${value}" in
				-i" "* | -i"	"*)
					value="${value##-i+([[:space:]])}"
					temp_ignore="true"
					;;
				--gitignore" "* | --gitignore"	"*)
					value="${value##--gitignore+([[:space:]])}"
					temp_ignore="true"
					;;
				-a" "* | -a"	"*)
					value="${value##-a+([[:space:]])}"
					temp_attrib="true"
					;;
				--gitattributes" "* | --gitattributes"	"*)
					value="${value##--gitattributes+([[:space:]])}"
					temp_attrib="true"
					;;
				--leader=*)
					value="${value#--leader=}"
					temp_leader="${value%%+([[:space:]])*}"
					value="${value:${#temp_leader}}"
					value="${value##+([[:space:]])}"
					;;
				--leader" "* | --leader"	"*)
					value="${value##--leader+([[:space:]])}"
					temp_leader="${value%%+([[:space:]])*}"
					value="${value:${#temp_leader}}"
					value="${value##+([[:space:]])}"
					;;
				--trailer=*)
					value="${value#--trailer=}"
					temp_trailer="${value%%+([[:space:]])*}"
					value="${value:${#temp_trailer}}"
					value="${value##+([[:space:]])}"
					;;
				--trailer" "* | --trailer"	"*)
					value="${value##--trailer+([[:space:]])}"
					temp_trailer="${value%%+([[:space:]])*}"
					value="${value:${#temp_trailer}}"
					value="${value##+([[:space:]])}"
					;;
				*)
					break
					;;
				esac
			done
			# assume path starting from '/' or '\' as VERSION_CONFIG_DIR-relative path, so normalize [\/] and remove leading / and ./
			case "${value}" in
			- | --)
				# print stamp to stdout (-) or read from stdin and print to stdout (--)
				# replace with special value which cannot be after path normalization
				temp_target="//${value}"
				;;
			*)
				temp_target="${value/#+(.\/|\/)/}"
				case "${temp_target}" in
				../* | ?:/*)
					# outside of config folder  OR  windows-style absolute
					__STDPATH_FUNCTION__ --var temp_target --directory "${VERSION_CONFIG_DIR}" --mixed -- "${temp_target}"
					;;
				*)
					# nothing
					;;
				esac
				;;
			esac
			if [[ -n ${STAMPER_KNOWN_TARGETS[${temp_target}]} ]]; then
				echo "Warning: Ignoring duplicate plugin-${temp_plugin} target file \"${temp_target}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			else
				if [[ -z ${STAMPER_PLUGINS[${temp_plugin}]} ]]; then
					echo "Warning: Ignoring unknown plugin-${temp_plugin} with target file \"${temp_target}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
				else
					index=${#STAMPER_CONF_PLUGIN[@]}
					STAMPER_KNOWN_TARGETS["${temp_target}"]="conf_${index}"
					STAMPER_CONF_PLUGIN[${index}]="${temp_plugin}"
					STAMPER_CONF_IGNORE[${index}]="${temp_ignore}"
					STAMPER_CONF_ATTRIB[${index}]="${temp_attrib}"
					STAMPER_CONF_TARGET[${index}]="${temp_target}"
					STAMPER_CONF_LEADER[${index}]="${temp_leader}"
					STAMPER_CONF_TRAILER[${index}]="${temp_trailer}"
					# target has VERSION_CONFIG_DIR-relative path
				fi
			fi
			unset temp_leader
			unset temp_trailer
			unset temp_ignore
			unset temp_attrib
			unset temp_plugin
			unset temp_target
			unset index
			;;
		authorship:)
			[[ -z ${VERSION_AUTHORSHIP} ]] && VERSION_AUTHORSHIP="$value" || echo "Warning: Ignoring duplicate authorship \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			;;
		declaration:)
			[[ -z ${VERSION_DECLARATION} ]] && VERSION_DECLARATION="$value" || echo "Warning: Ignoring duplicate copright/copyleft declration \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			;;
		default-cmd:)
			[[ -z ${STAMPER_DEFAULT_CMD} ]] && STAMPER_DEFAULT_CMD="$value" || echo "Warning: Ignoring duplicate default command \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			;;
		textoize:)
			if [[ -z ${STAMPER_TEXTOIZE} ]]; then
				if [[ -f ${STAMPER_SCRIPT_PATH}-textoize-${value} ]]; then
					STAMPER_TEXTOIZE="${STAMPER_SCRIPT_PATH}-textoize-${value}"
				else
					echo "Warning: Ignoring non-existent textoize script \"${STAMPER_SCRIPT_PATH}-textoize-${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
				fi
			else
				echo "Warning: Ignoring duplicate textoize script \"${value}\" at ${VERSION_CONFIG_PATH}:$cn" >&2
			fi
			;;
		*)
			# bad syntax ...
			DIE 2 "Bad configuration line \"${param}  ${value}\" at ${VERSION_CONFIG_PATH}:$cn"
			;;
		esac
	done
else
	__VERBOSE__ ".   It is not readable"
	VERSION_CONFIG_MISSING=" not found"
fi

#
# check some values, apply defaults
#
STAMPER_ABBREV_LEN="${STAMPER_ABBREV_LEN:-8}"
# if verbose mode was not assigned nor command line nor config file, then assume super-default 'false'
STAMPER_VERBOSE="${STAMPER_VERBOSE:-off}"

#
# nice 3-colon table-aligned printout functions
#   __triple_echo__  LEN1 TEXT1 LEN2 TEXT2 COMMENT
#
SPACE_ROW="                                                                                                                       "
function __triple_echo__
{
	echo "   $2 ${SPACE_ROW:0:$1-${#2}}= $4 ${SPACE_ROW:0:$3-${#4}} $5"
}

#
# get maximal length of argument of given arglist
#   __maxlen__ arg1 [arg2 [arg3 [...]]]
#
function __maxlen__
{
	a=${#1}
	shift
	while [[ -n $1 ]]; do
		b=${#1}
		[[ $b -gt $a ]] && a=$b
		shift
	done
	echo $a
}

# check list of hooks
if [ 0 -lt ${#STAMPER_HOOKS[@]} ]; then
	for hook in "${!STAMPER_HOOKS[@]}"; do
		case "${hook}" in
		none)
			unset STAMPER_HOOKS[${hook}]
			# no hooks at all
			;;
		*)
			# OK hook name, they were checked above, by configuration reader
			;;
		esac
	done
fi

#
# apply default command if needs
#
[[ "true" == ${STAMPER_USE_DEFAULT_CMD} ]] && set -- ${STAMPER_DEFAULT_CMD:---help}

#
# 2nd parse command line options (original or replaced with default command)
#
__VERBOSE__ "\nSecond arg parsing: <$*>"
STAMPER_EXECUTING_HOOK=""
# plugins to execute (given by the command line and/or config)
declare -a STAMPER_EXEC_PLUGIN
declare -a STAMPER_EXEC_TARGET
declare -a STAMPER_EXEC_IGNORE
declare -a STAMPER_EXEC_ATTRIB
declare -a STAMPER_EXEC_LEADER
declare -a STAMPER_EXEC_TRAILER
# clean known targets - we check duplicates in conf and in args separatelly
# then we will intellectually combine these lists if both '--generate' option and plugins given in command line
unset STAMPER_KNOWN_TARGETS
declare -A STAMPER_KNOWN_TARGETS
ref=""
ref_opt=""
temp_plugin=""
# note: temp_plugin is used also for syntax check - if it is non empty after parsing all args, then missing argument
temp_ignore="false"
temp_attrib="false"
temp_leader=""
temp_trailer=""
((an=0))
for arg in "$@"; do
	((an++))
	if [[ -n ${ref} ]]; then
		# assign *ref = 2nd_arg
		__VERBOSE__ ".        next arg ${an}: \"${arg}\""
		case "${ref}" in
		STAMPER_TEXTOIZE | \?STAMPER_TEXTOIZE)
			if [[ -f ${STAMPER_SCRIPT_PATH}-textoize-${arg} ]]; then
				if [[ "?" == ${ref:0:1} ]]; then
					[[ -z ${STAMPER_TEXTOIZE} ]] && STAMPER_TEXTOIZE="${STAMPER_SCRIPT_PATH}-textoize-${arg}"
				else
					[[ -n ${STAMPER_TEXTOIZE} ]] && echo "Warning: Override textoize setting \"${arg}\"" >&2
					STAMPER_TEXTOIZE="${STAMPER_SCRIPT_PATH}-textoize-${arg}"
				fi
			else
				echo "Warning: Ignoring non-existent --textoize script \"${STAMPER_SCRIPT_PATH}-textoize-${arg:11}\"" >&2
			fi
			;;
		\?*)
			ref="${ref:1}"
			[[ -n ${ref} && -z ${!ref} ]] && printf -v "${ref}" '%s' "${arg}"
			;;
		*)
			[[ ${ref} != "ref" && -n ${!ref} ]] && echo "Warning: Override ${ref_opt/#+(-)/} ref=\"${ref}\" val=\"${!ref}\" setting \"${arg}\"" >&2
			printf -v "${ref}" '%s' "${arg}"
			;;
		esac
		ref=""
	elif [[ -n ${temp_plugin} ]]; then
		# plugin specification; optional arguments -i | --gitignore and -a | --gitattributes
		__VERBOSE__ ".        plugin arg ${an}: \"${arg}\""
		case "${arg}" in
		-i | --gitignore)
			temp_ignore="true"
			;;
		-a | --gitattributes)
			temp_attrib="true"
			;;
		--leader=*)
			temp_leader="${arg:9}"
			;;
		--leader)
			ref="temp_leader"
			ref_opt="${arg}"
			;;
		--trailer=*)
			temp_trailer="${arg:10}"
			;;
		--trailer)
			ref="temp_trailer"
			ref_opt="${arg}"
			;;
		*)
			case "${arg}" in
			- | --)
				# stdout or stdin->stdout
				# replace with special value which cannot be after path normalization
				temp_target="//${arg}"
				;;
			/* | ?:/* | ../*)
				# absolute or worktree-relative path, normalize drive-letter form and case
				__STDPATH_FUNCTION__ --var temp_target --base "${VERSION_CONFIG_DIR}" --mixed -- "${arg}"
				;;
			*)
				# any other path (change \ to / and strip leading ./ and / -- usefull for pathes given by stamper config)
				__STDPATH_FUNCTION__ --var temp_target --base "${VERSION_CONFIG_DIR}" --mixed -- "${VERSION_CONFIG_DIR}/${arg/#+(.\/|\/)/}"
				;;
			esac
			if [[ -n ${STAMPER_KNOWN_TARGETS[${temp_target}]} && "//-" != ${temp_target} && "//--" != ${temp_target} ]]; then
				echo "Warning: Ignore duplicate plugin-${temp_plugin} target file \"${temp_target}\" at argument #$an" >&2
			else
				index=${#STAMPER_EXEC_PLUGIN[@]}
				STAMPER_KNOWN_TARGETS["${temp_target}"]="exec_${index}"
				STAMPER_EXEC_PLUGIN[${index}]="${temp_plugin}"
				STAMPER_EXEC_IGNORE[${index}]="${temp_ignore}"
				STAMPER_EXEC_ATTRIB[${index}]="${temp_attrib}"
				STAMPER_EXEC_TARGET[${index}]="${temp_target}"
				STAMPER_EXEC_LEADER[${index}]="${temp_leader}"
				STAMPER_EXEC_TRAILER[${index}]="${temp_trailer}"
			fi
			temp_trailer=""
			temp_leader=""
			temp_ignore="false"
			temp_attrib="false"
			temp_plugin=""
			unset temp_target
			;;
		esac
	else
		__VERBOSE__ ".    arg ${an}: \"${arg}\""
		case "${arg}" in
		-cd=* | --directory=*)
			;;				# proceed above, ignore it here
		-cd | --directory)
			ref="ref"		# proceed above, ignore it here
			ref_opt="${arg}"
			;;
		-V | --version)
			echo "${STAMPER_VERSION_TEXT}"
			EXIT 0			# proceed both above or here
			;;
		-h | --help | "/help" | "/?")
			# print help and exit
			echo -e "${STAMPER_SUITE_TITLE}"
			echo "
Usage:
   ${STAMPER_SCRIPT_NAME} [options] [commands]

The 'option' may have short form '-o' or long form '--option', it may have mandatory value or not.
Option with value must be used in form of single argument -o=value or --option=value
or in form of two arguments -o value or --option value

Available options are:
-V       --version
              Print version and exit.
-h  /?   --help  /help
              Print this help and exit.
-v       --verbose
              Print a lot of debugging information onto stderr.
-q       --quiet
              Turn off verbose mode.
-cd PATH --directory PATH
              Set current directory (somewere inside actual working tree), by default current directory.
-l       --list
              Print information about all available plugins and their configured target files.
-p       --print
              Print parsed information about current version.
-c       --config
              Create default configuration if missing.
-s       --setup
              Setup configured hooks force. This implies --config too.
-g       --generate
              Execute all configured plugins. This only applies to configured plugins in ${VERSION_CONFIG_NAME}.
              This implies --config and --setup too.
         --leader TEXT          --leader? TEXT
              Override configured leader text or assign new one if ${VERSION_CONFIG_NAME} is not exist;
              The last form '--leader?' assigns leader text if it was not set by configuration file.
         --trailer TEXT         --trailer? TEXT
              Override configured trailer text or assign new one if ${VERSION_CONFIG_NAME} is not exist;
              The last form '--traier?' assigns trailer text if it was not set by configuration file.
         --authorship TEXT      --authorship? TEXT
              Override configured authorship text or assign new one if ${VERSION_CONFIG_NAME} is not exist;
              The last form '--authorship?' assigns authorship text if it was not set by configuration file.
         --declaration TEXT     --declaration? TEXT
              Override configured declaration text or assign new one if ${VERSION_CONFIG_NAME} is not exist;
              The last form '--declaration?' assigns declaration text if it was not set by configuration file.
         --git-hook GITHOOK
              Use this option when version-stamper is running from git hook. It passes hook name (without path
              and leading '/' and/or '.'). This option turns on special processing during hook execution.
              Note: do not set it manually (except for test only), it must be used by corrresponding git hooks.

Available сommands are
              PLUGIN [plugin_options] FILE

Available plugin_options are:
-i       --gitignore
              Add generated file (on creation) into .gitignore file
-a       --gitattributes
              Add generated file (on creation) into .gitattributes file
--leader string
              Assign plugin-specific leader string, overrides configuration and common --leader setting.
--trailer string
              Assign plugin-specific trailer string, overrides configuration and common --trailer setting.

Available plugins 'PLUGIN' are:
$(for plugin in "${!STAMPER_PLUGINS[@]}"; do __PLUGIN_${plugin}_NOTICE__; done)
Generate or refresh file with actual version information.
If is not exist then create new file; elsewere read it and update version information if changed.
This allows to place any user-defined text in version files which will not be changed by ${STAMPER_SCRIPT_NAME}.

If no arguments given then ${STAMPER_SCRIPT_NAME} will use config parameter \"default-cmd\"
if it is not set or empty then \"--help\" will be assumed."
			EXIT 0
			;;
		-v | --verbose | -q | --quiet)
			# ignore it here because both command-line and configuration verbose args were proceed above.
			# so we may detect here new assignment only if both - command line and config does not specify verbose mode directly
			# while config file assigns it by 'transitive' mode - via default command.
			# this is too tricky to support it.
			;;
		--git-hook=*)
			STAMPER_EXECUTING_HOOK="${arg:11}"
			;;
		--git-hook)
			ref="STAMPER_EXECUTING_HOOK"
			ref_opt="${arg}"
			;;
		-c | --config)
			# create configuration here
			STAMPER_SETUP_CONFIG="true"
			;;
		-s | --setup)
			STAMPER_SETUP_CONFIG="true"
			STAMPER_SETUP_HOOKS="true"
			;;
		-g | --generate)
			# if we will generate version file(s) using missing config file then create it
			STAMPER_SETUP_CONFIG="true"
			[[ "false" == ${STAMPER_SETUP_HOOKS} ]] && STAMPER_SETUP_HOOKS="update"
			STAMPER_GENERATE="true"
			;;
		-l | --list)
			STAMPER_DO_LIST_PLUGINS="true"
			;;
		-p | --print)
			STAMPER_DO_PRINT_INFO="true"
			;;
		--leader=*)
			[[ -n ${VERSION_LEADER} ]] && echo "Warning: Override leader setting \"${arg:9}\"" >&2
			VERSION_LEADER="${arg:9}"
			;;
		--leader)
			ref="VERSION_LEADER"
			ref_opt="${arg}"
			;;
		--trailer=*)
			[[ -n ${VERSION_TRAILER} ]] && echo "Warning: Override trailer setting \"${arg:10}\"" >&2
			VERSION_TRAILER="${arg:10}"
			;;
		--trailer)
			ref="VERSION_TRAILER"
			ref_opt="${arg}"
			;;
		--authorship=*)
			[[ -n ${VERSION_AUTHORSHIP} ]] && echo "Warning: Override authorship setting \"${arg:13}\"" >&2
			VERSION_AUTHORSHIP="${arg:13}"
			;;
		--authorship)
			ref="VERSION_AUTHORSHIP"
			ref_opt="${arg}"
			;;
		--declaration=*)
			[[ -n ${VERSION_DECLARATION} ]] && echo "Warning: Override declaration setting \"${arg:14}\"" >&2
			VERSION_DECLARATION="${arg:14}"
			;;
		--declaration)
			ref="VERSION_DECLARATION"
			ref_opt="${arg}"
			;;
		--leader\?=*)
			[[ -z ${VERSION_LEADER} ]] && VERSION_LEADER="${arg:10}"
			;;
		--leader\?)
			ref="?VERSION_LEADER"
			ref_opt="${arg}"
			;;
		--trailer\?=*)
			[[ -z ${VERSION_TRAILER} ]] && VERSION_TRAILER="${arg:11}"
			;;
		--trailer\?)
			ref="?VERSION_TRAILER"
			ref_opt="${arg}"
			;;
		--authorship\?=*)
			[[ -z ${VERSION_AUTHORSHIP} ]] && VERSION_AUTHORSHIP="${arg:14}"
			;;
		--authorship\?)
			ref="?VERSION_AUTHORSHIP"
			ref_opt="${arg}"
			;;
		--declaration\?=*)
			[[ -z ${VERSION_DECLARATION} ]] && VERSION_DECLARATION="${arg:15}"
			;;
		--declaration\?)
			ref="?VERSION_DECLARATION"
			ref_opt="${arg}"
			;;
		--textoize=*)
			if [[ -f ${STAMPER_SCRIPT_PATH}-textoize-${arg:11} ]]; then
				[[ -n ${STAMPER_TEXTOIZE} ]] && echo "Warning: Override textoize setting \"${arg:11}\"" >&2
				STAMPER_TEXTOIZE="${STAMPER_SCRIPT_PATH}-textoize-${arg:11}"
			else
				echo "Warning: Ignoring non-existent --textoize script \"${STAMPER_SCRIPT_PATH}-textoize-${arg:11}\"" >&2
			fi
			;;
		--textoize)
			ref="STAMPER_TEXTOIZE"
			ref_opt="${arg}"
			;;
		--textoize\?=*)
			if [[ -f ${STAMPER_SCRIPT_PATH}-textoize-${arg:12} ]]; then
				[[ -z ${STAMPER_TEXTOIZE} ]] && STAMPER_TEXTOIZE="${STAMPER_SCRIPT_PATH}-textoize-${arg:12}"
			else
				echo "Warning: Ignoring non-existent --textoize script \"${STAMPER_SCRIPT_PATH}-textoize-${arg:12}\"" >&2
			fi
			;;
		--textoize\?)
			ref="?STAMPER_TEXTOIZE"
			ref_opt="${arg}"
			;;
		*)
			if [[ -n ${STAMPER_PLUGINS[${arg}]} ]]; then
				temp_plugin="${arg}"
			else
				DIE 2 "Wrong argument(s): \"${arg}\""
			fi
			;;
		esac
	fi
done
[[ -n ${ref} ]] && DIE 2 "Wrong argument(s): \"${ref_opt}\" needs in argument after"
[[ -n ${temp_plugin} ]] && DIE 2 "Wrong plugin command: \"${temp_plugin}\" needs in argument after"
unset temp_leader
unset temp_trailer
unset temp_attrib
unset temp_ignore
unset temp_plugin
unset ref_opt
unset ref
unset an

if [[ -n ${VERSION_CONFIG_PREFIX} ]]; then
	[[ "false" != ${STAMPER_SETUP_HOOKS} && 0 -ne ${#STAMPER_HOOKS[@]} ]] && echo "Warning: do not update git hooks because \"${VERSION_CONFIG_DIR}\" differs from worktree root \"${VERSION_ROOT_DIR}\"" >&2
	STAMPER_SETUP_HOOKS="false"
fi
if [[ "true" == ${STAMPER_GENERATE} ]]; then
	# if option -g / --generate was used then add configured plugins to the list of executed
	for iconf in "${!STAMPER_CONF_PLUGIN[@]}"; do
		found="false"
		for iexec in "${!STAMPER_EXEC_PLUGIN[@]}"; do
			if [[ ${STAMPER_EXEC_TARGET[${iexec}]} == ${STAMPER_CONF_TARGET[${iconf}]} ]]; then
				# assume conf has priority over command line
				found="true"
				if [[ ${STAMPER_EXEC_PLUGIN[${iexec}]} != ${STAMPER_CONF_PLUGIN[${iconf}]} ]]; then
					echo "Warning! use configured plugin \"${STAMPER_CONF_PLUGIN[${iconf}]}\" rather than given by command line \"${STAMPER_EXEC_PLUGIN[${iexec}]}\" for \"${STAMPER_EXEC_TARGET[${iexec}]}\"" 1>&2
					STAMPER_EXEC_PLUGIN[${iexec}]="${STAMPER_CONF_PLUGIN[${iconf}]}"
				fi
				# use options from config
				STAMPER_EXEC_IGNORE[${iexec}]="${STAMPER_CONF_IGNORE[${iconf}]}"
				STAMPER_EXEC_ATTRIB[${iexec}]="${STAMPER_CONF_ATTRIB[${iconf}]}"
				STAMPER_EXEC_LEADER[${iexec}]="${STAMPER_CONF_LEADER[${iconf}]}"
				STAMPER_EXEC_TRAILER[${iexec}]="${STAMPER_CONF_TRAILER[${iconf}]}"
				break
			fi
		done
		if [[ "false" == ${found} ]]; then
			iexec=${#STAMPER_EXEC_PLUGIN[@]}
			STAMPER_EXEC_PLUGIN[${iexec}]="${STAMPER_CONF_PLUGIN[${iconf}]}"
			STAMPER_EXEC_TARGET[${iexec}]="${STAMPER_CONF_TARGET[${iconf}]}"
			STAMPER_EXEC_IGNORE[${iexec}]="${STAMPER_CONF_IGNORE[${iconf}]}"
			STAMPER_EXEC_ATTRIB[${iexec}]="${STAMPER_CONF_ATTRIB[${iconf}]}"
			STAMPER_EXEC_LEADER[${iexec}]="${STAMPER_CONF_LEADER[${iconf}]}"
			STAMPER_EXEC_TRAILER[${iexec}]="${STAMPER_CONF_TRAILER[${iconf}]}"
		fi
		unset found
		unset iexec
	done
	unset iconf
else
	[[ 0 != ${#STAMPER_EXEC_PLUGIN[@]} ]] && STAMPER_GENERATE="true"
fi

# get summary list of executed targets
unset STAMPER_KNOWN_TARGETS
declare -A STAMPER_KNOWN_TARGETS
for index in "${!STAMPER_CONF_TARGET[@]}"; do
	STAMPER_KNOWN_TARGETS["${STAMPER_CONF_TARGET[${index}]}"]="conf_${index}"
done
for index in "${!STAMPER_EXEC_TARGET[@]}"; do
	temp_target="${STAMPER_EXEC_TARGET[${index}]}"
	[[ -z ${STAMPER_KNOWN_TARGETS[${temp_target}]} ]] && STAMPER_KNOWN_TARGETS["${temp_target}"]="exec_${index}"
done
unset temp_target
unset index

VERSION_GIT_USER="$(git --no-pager config user.name 2>/dev/null)"
VERSION_GIT_EMAIL="$(git --no-pager config user.email 2>/dev/null)"
if [[ -z ${VERSION_GIT_USER} ]]; then
	if [[ -n ${USER} ]]; then
		# linux-style
		VERSION_GIT_USER="${USER}"
	elif [[ -n ${USERNAME} ]]; then
		# windows-style
		VERSION_GIT_USER="${USERNAME}"
	else
		VERSION_GIT_USER="Unknown User"
	fi
fi
if [[ -z ${VERSION_GIT_EMAIL} ]]; then
	VERSION_GIT_EMAIL="${VERSION_GIT_USER//+([!A-Za-z0-9_])/_}"
	VERSION_GIT_EMAIL="${VERSION_GIT_EMAIL/#_/}"
	VERSION_GIT_EMAIL="${VERSION_GIT_EMAIL/%_/}@localhost"
fi
__VERBOSE__ "git config user.name and user.email\n.   VERSION_GIT_USER=${VERSION_GIT_USER}\n.   VERSION_GIT_EMAIL=${VERSION_GIT_EMAIL}"

__VERBOSE__ "Check and update missing information (authorship and copyright/copyleft)"
# authorship name must be determined once and then saved into config file
if [[ -z ${VERSION_AUTHORSHIP} ]]; then
	__VERBOSE__ "Authorship is not set, try to detect it"
	VERSION_AUTHORSHIP="${VERSION_GIT_USER}"
	if [[ -n ${VERSION_AUTHORSHIP} ]]; then
		[[ -n ${VERSION_GIT_EMAIL} ]] && VERSION_AUTHORSHIP="${VERSION_AUTHORSHIP} <${VERSION_GIT_EMAIL}>"
		__VERBOSE__ "Authorship is based on git config\n.   VERSION_AUTHORSHIP=${VERSION_AUTHORSHIP}"
	else
		if [[ "Windows_NT" == ${OS} ]]; then
			util="$(which reg.exe 2>/dev/null)"
			if [[ -n ${util} ]]; then
				VERSION_AUTHORSHIP=$(MSYS_NO_PATHCONV=1 "${util}" query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion" /t REG_SZ /v RegisteredOrganization 2>/dev/null \
						| awk -v RS='(\r\n|\n\r|\r|\n)' '/^\s*RegisteredOrganization/ { w=""; for ( i=3; i<=NF; i++ ) w = w $i " "; print gensub( "\\s+$", "", 1, w ); }')
				__VERBOSE__ ".   this is windows; try \"$util\" to get authorship\n.      \"${VERSION_AUTHORSHIP}\""
			fi
		else
			VERSION_AUTHORSHIP="${USER:-$USERNAME}"
			VERSION_AUTHORSHIP="${VERSION_AUTHORSHIP:-$(whoami)}"
			__VERBOSE__ ".   this is *nix; try username instead of authorship\n.      \"${VERSION_AUTHORSHIP}\""
		fi
	fi
fi
VERSION_AUTHORSHIP="${VERSION_AUTHORSHIP:-Unknown Author}"

# copyright/copyleft text must be determined once and then saved into config file
#    normally it must use personal or company name and initial date of project
if [[ -z ${VERSION_DECLARATION} ]]; then
	# get year of first commit
	temp="$(git --no-pager log -n 1 --reverse --date="format:%Y" --pretty="format:%ad" 2>/dev/null)"
	VERSION_DECLARATION="${STAMPER_DEFAULT_DECL:-Copyright (c)} ${VERSION_AUTHORSHIP} ${temp:-$(date "+%Y")}"
	unset temp
	__VERBOSE__ "Assume authorship declaration:\n.   ${VERSION_DECLARATION}"
fi

#
# Print now (after getting actual verbose mode) detected parameters at current point:
#
__VERBOSE__ "
Config file${VERSION_CONFIG_MISSING}: \"${VERSION_CONFIG_PATH}\"
.   verbose= \"${STAMPER_VERBOSE,,}\"
.   abbreviation length= \"${STAMPER_ABBREV_LEN}\"
.   leader= \"${VERSION_LEADER}\"
.   trailer= \"${VERSION_TRAILER}\"
.   authorship= \"${VERSION_AUTHORSHIP}\"
.   authorship declaration= \"${VERSION_DECLARATION}\"
.   default command= \"${STAMPER_DEFAULT_CMD}\"
.   check/create config=\"${STAMPER_SETUP_CONFIG}\"
.   setup hooks=\"${STAMPER_SETUP_HOOKS}\"
.   Hooks to update=[${!STAMPER_HOOKS[@]}]
.   generate stamps=\"${STAMPER_GENERATE}\" [${STAMPER_EXEC_PLUGIN[@]}]"
for index in "${!STAMPER_EXEC_PLUGIN[@]}"; do
	plugin="${STAMPER_EXEC_PLUGIN[$index]}"
	target="${STAMPER_EXEC_TARGET[$index]}"
	if [[ -n ${STAMPER_PLUGINS[$plugin]} ]]; then
		__VERBOSE__ ".   .   run plugin \"$plugin\" with file \"${target}\", gitignore=${STAMPER_EXEC_IGNORE[$index]}, gitattributes=${STAMPER_EXEC_ATTRIB[$index]}"
	else
		DIE 3 "Unknown plugin 'plugin-$plugin: $plugin'; not found '${STAMPER_SCRIPT_PATH}-plugin-$plugin'."
	fi
	unset target
	unset plugin
done

#
# get rest of version data
#
# get version designator from 'git describe'
# note: --match is not an regex, it is 'glob(7)', so '.' means dot, '^', '+', '$' cannot be used etc
# pattern '[A-Za-z][0-9]*.[0-9]*' match to v1.2 and v1.2.3 while v1, v1.2b and ab1.2 are not matching
__VERBOSE__ "\nDetect version data"
VERSION_TEXT="$(git --no-pager describe --long --tags --match="[A-Za-z][0-9]*.[0-9]*" HEAD 2>/dev/null)"
if [[ $? -ne 0 || -z ${VERSION_TEXT} ]]; then
	# simulate if no version tags found
	temp="$(git --no-pager rev-list --count HEAD 2>/dev/null)"
	if [[ $? -ne 0 || -z ${temp} || -1 -eq ${temp} ]]; then
		__VERBOSE__ ".   'git describe' and 'git rev-list --count' both are failed; assume\n.   VERSION_TEXT='v0.0-0'"
		VERSION_TEXT="v0.0-0"
	else
		__VERBOSE__ ".   'git describe' failed, 'git rev-list --count HEAD' returns '${temp}'; assume\n.   VERSION_TEXT='v0.0-$temp'"
		VERSION_TEXT="v0.0-$temp"
	fi
	unset temp
else
	VERSION_TEXT="${VERSION_TEXT%%-g*}"
	__VERBOSE__ ".   git describe --long --tags --match=\"[A-Za-z][0-9]*.[0-9]*\" HEAD\n.   VERSION_TEXT='${VERSION_TEXT}'"
fi
# VERSION_TEXT now may be destroyed; it will be reconstructed later using textoize addon
VERSION_BUILD="${VERSION_TEXT##*-}";   VERSION_SUFFIX="${VERSION_TEXT%-*}"
VERSION_PREFIX="${VERSION_TEXT:0:1}";  VERSION_SUFFIX="${VERSION_SUFFIX:1}"
VERSION_MAJOR="${VERSION_SUFFIX%%.*}"; VERSION_SUFFIX="${VERSION_SUFFIX#*.}"
VERSION_MINOR="${VERSION_SUFFIX%%.*}"; VERSION_SUFFIX="${VERSION_SUFFIX:${#VERSION_MINOR}}"
__VERBOSE__ "parsed data:\n.   VERSION_PREFIX=${VERSION_PREFIX}\n.   VERSION_MAJOR=${VERSION_MAJOR}\n.   VERSION_MINOR=${VERSION_MINOR}\n.   VERSION_SUFFIX=${VERSION_SUFFIX}\n.   VERSION_BUILD=${VERSION_BUILD}"

# get date
eval $(date +"VERSION_DATE=\"%Y-%m-%d %H:%M:%S\"; VERSION_SHORTDATE=\"%y%m%d%H%M%S\"; VERSION_UNIXTIME=%s;")
__VERBOSE__ "now\n.   VERSION_DATE=${VERSION_DATE}\n.   VERSION_SHORTDATE=${VERSION_SHORTDATE}\n.   VERSION_UNIXTIME=${VERSION_UNIXTIME}"

# get SHA1
VERSION_SHA_LONG="$(git --no-pager rev-parse HEAD 2>/dev/null)"
__VERBOSE__ "git rev-parse HEAD\n.   VERSION_SHA_LONG=${VERSION_SHA_LONG}"
if [[ "HEAD" == ${VERSION_SHA_LONG} ]]; then
	VERSION_SHA_LONG="0000000000000000000000000000000000000000"
	__VERBOSE__ ".   assume VERSION_SHA_LONG=0000000000000000000000000000000000000000"
fi

# get branch name
VERSION_BRANCH="$(git --no-pager rev-parse --abbrev-ref HEAD 2>/dev/null)"
__VERBOSE__ "\nGet branch name\ngit rev-parse --abbrev-ref HEAD\n.   VERSION_BRANCH=${VERSION_BRANCH}"
if [[ "HEAD" == ${VERSION_BRANCH} || -z ${VERSION_BRANCH} ]]; then
	# detached head:
	#
	# 0) try to read content of HEAD
	# note 1: HEAD may contain text "SHA1"  or  "ref: refs/heads/branchname"
	# note 2: this looks strange ("ref: ... syntax" means attached head, so git rev-parse ... must be OK) but ...
	# note 3: fresh-created repo has HEAD equal to "ref: refs/heads/master" but head file ".git/refs/heads/master" is not exist
	VERSION_BRANCH="$(awk -v RS='(\r\n|\n\r|\r|\n)' 'match( $0, /^(ref:\s+refs\/heads\/)(.*)/, A ) { print A[2]; next; } { print ""; }' "${VERSION_GIT_DIR}/HEAD")"
	__VERBOSE__ "awk -v RS='(\\\\r\\\\n|\\\\n\\\\r|\\\\r|\\\\n)' 'match( \$0, /^(ref:\s+refs\/heads\/)(.*)/, A ) { print A[2]; next; } { print \"\"; }' \"\${VERSION_GIT_DIR}/HEAD\"\n.   VERSION_BRANCH='${VERSION_BRANCH}'  (by reading HEAD file)"
	if [[ -z ${VERSION_BRANCH} ]]; then
		if [[ -n ${VERSION_SUBMOD_NAME} ]]; then
			temp_branch="$(git -C "${VERSION_SUPER_DIR}" --no-pager config --file="./.gitmodules" --get "submodule.${VERSION_SUBMOD_NAME}.branch" 2>/dev/null)"
			__VERBOSE__ "Check submodule-assigned branch name\ngit config --file=\"${VERSION_SUPER_DIR}/.gitmodules\" --get \"submodule.${VERSION_SUBMOD_NAME}.branch\"\n.   branch='${temp_branch}'"
			if [[ -n ${temp_branch} ]]; then
				# submodule has assigned branch (git will use detached head regardless of branch assignment ... only manual intervention may checkout branch)
				temp="$(git --no-pager for-each-ref "refs/remotes/*/${temp_branch}" "refs/heads/${temp_branch}" --contains=HEAD 2>/dev/null)"
				# if temp non-empty then HEAD is somewhere on assigned branch
				case "${STAMPER_VERBOSE,,}" in
				simple | extended)
					# avoid complex string expansion using subshell execution if result is unused
					__VERBOSE__ ".   Branch is assigned, HEAD is on given branch history?\n.   git for-each-ref \"refs/remotes/*/${temp_branch}\" \"refs/heads/${temp_branch}\"\n$(echo "${temp}" | sed -e 's/^.*$/.   .   &/' )"
					;;
				esac
				if [[ -z ${temp} ]]; then
					# may be branch heads are in past -- some commits were made on detached HEAD in we are in future?
					# use git rev-list to read history of commits from HEAD down to initial commit
					# and check if local or remote branch with '${temp_branch}' name if on way ...
					# git for-each-ref prints all SHAs of matched branches, grep filters history
					temp="$(git --no-pager rev-list HEAD | grep $(git --no-pager for-each-ref "refs/remotes/*/${temp_branch}" "refs/heads/${temp_branch}" --format="-e %(objectname)" 2>/dev/null))"
					case "${STAMPER_VERBOSE,,}" in
					simple | extended)
						# avoid complex string expansion using subshell execution if result is unused
						__VERBOSE__ ".   .   may be this branch is on HEAD history?\n.   .   git rev-list HEAD | grep \$(git for-each-ref \"refs/remotes/*/${temp_branch}\" \"refs/heads/${temp_branch}\" --format=\"-e %(objectname)\")\n\n$(echo "${temp}" | sed -e 's/^.*$/.   .   .   &/' )"
						;;
					esac
					# some like may be made by 'git log --ancestry-path OLD..NEW' ... but assigned branch may be as local as remote and we may have few SHAs matched same name
					# so ... did few attempts for few kinds of branches or use grep to check few variants at once
				fi
				if [[ -n ${temp} ]]; then
					# assigned head may be used for our submodule - HEAD is on branch history or vice versa - branch is on HEAD history
					VERSION_BRANCH="${temp_branch}"
					__VERBOSE__ ".   VERSION_BRANCH=\"${VERSION_BRANCH}\""
				fi
			fi
			unset temp_branch
		fi
		if [[ -z ${VERSION_BRANCH} ]]; then
			VERSION_BRANCH="$(git --no-pager name-rev --name-only --exclude="tags/*" --exclude="remotes/*" --exclude="pipelines/*" ${VERSION_SHA_LONG} 2>/dev/null)"
			VERSION_BRANCH="${VERSION_BRANCH%~[0-9]*}"
			__VERBOSE__ "Is there local or remote head matching our head?\ngit name-rev --name-only --exclude=\"tags/*\" --exclude=\"remotes/*\" --exclude=\"pipelines/*\" ${VERSION_SHA_LONG}\n.   VERSION_BRANCH=${VERSION_BRANCH}"
			if [[ "undefined" == ${VERSION_BRANCH} ]]; then
				# note: git name-rev may return empty string (if reference does not match any commits, for example sha=0000...0000)
				# or 'undefined' if sha is OK and no names found (in tests: where all names are in past, i.e. detached head has few commits after branch head)
				# this is potential trouble - if real branch has name 'undefined' then it may be miss with really undefined reference.
				# (exit codes of 'git name-rev' in all observed cases were 0)
				__VERBOSE__ ".   Try to look for heads in past instead of \"undefined\" branch"
				__VERBOSE__ ".   a) scan local and remote heads:\n.   git for-each-ref \"refs/remotes\" \"refs/heads\" --format=\"%(objectname) %(refname:lstrip=1)\""
				declare -A temp_heads
				git --no-pager for-each-ref "refs/remotes" "refs/heads" --format="%(objectname) %(refname:lstrip=1)" | while read temp_sha temp_ref; do
					case "${temp_ref%%/*}" in
					heads)
						temp_heads["${temp_sha}"]="${temp_ref#*/}"
						;;
					remotes)
						temp_heads["${temp_sha}"]="${temp_ref#remotes/*/}"
						;;
					*)
						temp_heads["${temp_sha}"]="${temp_ref##*/}"
						;;
					esac
					__VERBOSE__ ".   .   ${temp_sha} := ${temp_heads[${temp_sha}]} (${temp_ref})"
				done
				__VERBOSE__ ".   b) look at history:\n.   git rev-list HEAD"
				git --no-pager rev-list HEAD |while read temp_sha; do
					__VERBOSE__ ".   .   ${temp_sha} is '${temp_heads[${temp_sha}]}'"
					if [[ -n ${temp_heads[${temp_sha}]} ]]; then
						VERSION_BRANCH="${temp_heads[${temp_sha}]}"
						__VERBOSE__ ".   .   .   VERSION_BRANCH=\"${VERSION_BRANCH}\""
						break
					fi
				done
				unset temp_heads
				unset temp_sha
				unset temp_ref
			fi
		fi
		if [[ -z ${VERSION_BRANCH} ]]; then
			__VERBOSE__ ".   Branch remains unknown, try to look for heads in future"
			temp_remote=""
			git --no-pager for-each-ref "refs/remotes/" "refs/heads/" --format="%(refname:lstrip=1)" --contains=HEAD |while read temp_ref; do
				__VERBOSE__ ".   .   '${temp_ref}'"
				[[ "HEAD" == ${temp_ref##*/} ]] && continue
				case "${temp_ref}" in
				remotes/*)
					case "${temp_remote}" in
					"")
						temp_remote="${temp_ref#*/}"
						;;
					":")
						;;
					*)
						temp_remote=":"
						;;
					esac
					;;
				heads/*)
					case "${temp}" in
					"")
						temp="${temp_ref#*/}"
						;;
					":")
						;;
					*)
						temp=":"
						;;
					esac
					;;
				esac
			done
			unset temp_ref
			if [[ -n "${temp}" && ":" != "${temp}" ]]; then
				VERSION_BRANCH="${temp}"
			elif [[ -n "${temp_remote}" && ":" != "${temp_remote}" ]]; then
				VERSION_BRANCH="${temp_remote}"
			fi
            [[ -n ${VERSION_BRANCH} ]] && __VERBOSE__ ".   VERSION_BRANCH=\"${VERSION_BRANCH}\""
			unset temp_remote
		fi
		unset temp
		if [[ -z ${VERSION_BRANCH} ]]; then
			VERSION_BRANCH="?UNKNOWN"
			__VERBOSE__ ".   VERSION_BRANCH=${VERSION_BRANCH}  (assume unknown)"
		fi
	fi
fi

#
# note: VERSION_SHA_LONG may be changed depnded on situation (executing hook).
#
VERSION_DIRTY=""
# 1) pre-commit needs in special logic to detect DIRTY state and parent commit (amend!)
# 2) post-merge needs in configuration file check -- we must leve it in correct
#    state (avoid syntax errors on next reading); the DIRTY deteted is same as (3)
# 3) all other cases
if [[ "pre-commit" == ${STAMPER_EXECUTING_HOOK} ]]; then
	__VERBOSE__ "\nDetect DIRTY status for pre-commit hook"
	# now ... commit may be used in many scenarios:
	# - regular commit: VERSION_SHA_LONG is a SHA of current commit, so when actual commit will be created VERSION_SHA_LONG becomes 'SHA of parent commit'
	# - amend commit: VERSION_SHA_LONG referencies to sha of amended commit, so it becomes wrong ;(
	#   theoretically we may use 'grand parent' sha here as parent sha
	# - squash commit: same as amend ...
	#   but few commits will be removed, so we needs in actual parent
	# - merge commit: ...
	amend=""
	if [[ "Windows_NT" == ${OS} ]]; then
		# this is a trick - we get all git.exe instances and look for --amend text; this may be wrong due to
		# mismatch instance of git.exe and placing text --amend somewhere inside text args...
		# ... somewhere this may work :(
		util="$(which WMIC.exe 2>/dev/null)"
		if [[ -n ${util} ]]; then
			amend="$(MSYS_NO_PATHCONV=1 "${util}" path win32_process where "Caption='git.exe'" get Commandline| awk -v RS='(\r\n|\n\r|\r|\n)' '/--amend/ { print "true"; }')"
		fi
	else
		# this may work under *nix... but windows :(
		amend=""
		temp="$(ps -f -p $PPID |awk -v RS='(\r\n|\n\r|\r|\n)' 'BEGIN{ N=-1; } -1 == N { for (i=1;i<=NF;i++) if ( $i == "PPID" ) { N=i; break; } next; } { print $N; }')"
		if [[ -n ${temp} ]]; then
			if [[ -f /proc/${temp}/cmdline ]]; then
				__VERBOSE__ ".    look at /proc/$temp/cmdline"
				for arg in $(xargs -n1 --null </proc/$temp/cmdline); do
					__VERBOSE__ ".    arg = $arg"
					[[ ${arg} == "--amend" ]] && amend="true"
				done
			fi
		fi
	fi
	# apply detected options
	if [[ -z ${amend} ]]; then
		((VERSION_BUILD++))
		__VERBOSE__ "This is regular commit; increase VERSION_BUILD, now VERSION_BUILD=${VERSION_BUILD}"
	else
		# distance does not changed; while VERSION_SHA_LONG is wrong, try to get grandparent SHA
		__VERBOSE__ "This is amend commit; remain VERSION_BUILD unchanged"
		# there may be few parents of given commit, so get them all as VERSION_SHA_LONG
		# use --sq, so 'git rev-parse' will print all sha on same line; without --q it will print one sha per line
		temp="$(git --no-pager rev-parse --sq ${VERSION_SHA_LONG}^@ 2>/dev/null)"
		temp="${temp//\'/}"
		__VERBOSE__ "git rev-parse --sq ${VERSION_SHA_LONG}^\n.   temp=$temp"
		if [[ -z ${temp} || ${temp} == ${VERSION_SHA_LONG} ]]; then
			temp="0000000000000000000000000000000000000000"
			__VERBOSE__ ".   assume temp=0000000000000000000000000000000000000000"
		fi
		VERSION_SHA_LONG="${temp}"
	fi
	# VERSION_SHA_LONG may be list of sha... add 'p:' prefix to all
	declare -a sha_temp
	for sha in ${VERSION_SHA_LONG}; do sha_temp[${#sha_temp[@]}]="p:${sha}"; done
	VERSION_SHA_LONG="${sha_temp[@]}"
	unset sha_temp
	unset amend
	# check changes of files; skip all non-indexed and ignored files; assume commited for indexed files;
	# and detect changed in worktree non-target files - if ones exist then mark repo as dirty
	__VERBOSE__ "git status --porcelain --untracked-files=normal"
	git --no-pager status --porcelain --untracked-files=normal 2>/dev/null | \
	awk -v RS='(\r\n|\n\r|\r|\n)' 'match( $0, /^[!?][!?]\s+(.*)$/, A ) { print "o " A[1]; next; }
         match( $0, /^.[MTADRCU]\s+((.*)\s+->\s+.*|(.*))$/, A ) { print "X " ( A[2] == "" ? A[3] : A[2] ); next; }
         match( $0, /^..\s+((.*)\s+->\s+.*|(.*))$/, A ) { print "C " ( A[2] == "" ? A[3] : A[2] ); next; }' | \
	while read changed file; do
		case "${changed}" in
		o)
			# not in index (ignored or not added)
			__VERBOSE__ ".    \"${file}\" is not in index, so its changes are not taken into account"
			;;
		X)
			# has changed in worktree
			if [[ -z ${STAMPER_KNOWN_TARGETS[${file#${VERSION_CONFIG_PREFIX}}]} ]]; then
				__VERBOSE__ ".    \"${file}\" changed, worktree remains dirty"
				VERSION_DIRTY="+"
				[[ "off" == ${STAMPER_VERBOSE,,} ]] && break
			else
				__VERBOSE__ ".    \"${file}\" is the target file, so changes to it are not taken into account"
			fi
			;;
		C)
			# has indexed changes -- will be commited during this action (we are under pre-commit hook)
			__VERBOSE__ ".    \"${file}\" is in commit already"
			;;
		*)
			__VERBOSE__ ".    \"${file}\" WRONG CLASSIFICATION"
			;;
		esac
	done
fi

if [[ "post-merge" == ${STAMPER_EXECUTING_HOOK} ]]; then
	git --no-pager status --porcelain --untracked-files=normal -- ":/:${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}"  2>/dev/null | while read status file; do
		case "$status" in
		AA | AU | UA | UU | DU | UD | DD)
			__STORE_NATIVE_EOL__ "${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}" <<<"$(__READ_LF__ "${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}")"
			;;
		*)
			;;
		esac
	done
fi
if [[ "pre-commit" != ${STAMPER_EXECUTING_HOOK} ]]; then
	# all other hooks except pre-commit
	__VERBOSE__ "\nDetect DIRTY status for common case (manual or any hook except pre-commit)\ngit status --porcelain --untracked-files=normal"
	git --no-pager status --porcelain --untracked-files=normal 2>/dev/null | \
	awk -v RS='(\r\n|\n\r|\r|\n)' 'match( $0, /^[!?][!?]\s+(.*)$/, A ) { print "o " A[1]; next; }
         match( $0, /^.[MTADRCU]\s+((.*)\s+->\s+.*|(.*))$/, A ) { print "X " ( A[2] == "" ? A[3] : A[2] ); next; }
         match( $0, /^..\s+((.*)\s+->\s+.*|(.*))$/, A ) { print "C " ( A[2] == "" ? A[3] : A[2] ); next; }' | \
	while read changed file; do
		case "${changed}" in
		o)
			# not in index (ignored or not added)
			__VERBOSE__ ".    \"${file}\" is not in index, so changes to it are not taken into account"
			;;
		X | C)
			# X - has changes in worktree
			# C - has indexed changes
			if [[ -z ${STAMPER_KNOWN_TARGETS[${file#${VERSION_CONFIG_PREFIX}}]} ]]; then
				__VERBOSE__ ".    \"${file}\" changed, worktree remains dirty"
				VERSION_DIRTY="+"
				[[ "off" == ${STAMPER_VERBOSE,,} ]] && break
			else
				__VERBOSE__ ".    \"${file}\" is the target file, so changes to it are not taken into account"
			fi
			;;
		*)
			__VERBOSE__ ".    \"${file}\" WRONG CLASSIFICATION"
			;;
		esac
	done
fi

#
# build final SHA abbreviation (VERSION_SHA_SHORT), version text (VERSION_TEXT) and numeric identification (VERSION_ID)
#
declare -a sha_temp
for sha in ${VERSION_SHA_LONG}; do
	temp="${sha#[pP]:}"
	sha_temp[${#sha_temp[@]}]="${sha%%[0-9a-fA-F]*}${temp:0:STAMPER_ABBREV_LEN}"
done
VERSION_SHA_SHORT="${sha_temp[@]}"
unset sha_temp
unset temp

printf -v VERSION_ID "%02X%02X%04X" "${VERSION_MAJOR}" "${VERSION_MINOR}" "${VERSION_BUILD}"
VERSION_TEXT=""
[[ -n ${STAMPER_TEXTOIZE} ]] && source "${STAMPER_TEXTOIZE}"
[[ -z ${VERSION_TEXT} ]] && VERSION_TEXT="${VERSION_PREFIX}${VERSION_MAJOR}.${VERSION_MINOR}${VERSION_SUFFIX}.${VERSION_BUILD}-${VERSION_BRANCH}${VERSION_DIRTY}"

#
# print specific reply for some hooks (all VERSION_* vars must be calculated at this point)
#
case "${STAMPER_EXECUTING_HOOK}" in
post-commit | post-rewrite | post-merge)
	echo "(${VERSION_TEXT})"
	;;
*)
	;;
esac

__VERBOSE__ "\nExecute wanted operations -- create config, generate version file, print info etc"
if [[ ! -f ${VERSION_CONFIG_PATH} ]]; then
	if [[ -n ${VERSION_SUBMOD_NAME} && -z ${VERSION_LEADER} ]]; then
		VERSION_LEADER="${VERSION_SUBMOD_NAME//+([!A-Za-z0-9_])/_}"
		VERSION_LEADER="${VERSION_LEADER/#+_/}"
		VERSION_LEADER="${VERSION_LEADER/%+_/}"
		VERSION_LEADER="${VERSION_LEADER^^}_"
	fi
	if [[ "true" == ${STAMPER_SETUP_CONFIG} ]]; then
		# create initial config file
		if [[ 0 -eq ${#STAMPER_HOOKS[@]} ]]; then
			STAMPER_HOOKS["pre-commit"]="true"
			# the STAMPER_HOOKS["post-commit"] is not used by default
			STAMPER_HOOKS["post-checkout"]="true"
			STAMPER_HOOKS["post-rewrite"]="true"
			STAMPER_HOOKS["post-merge"]="true"
		fi
		__VERBOSE__ "Create config file \"${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}\""
		__STORE_NATIVE_EOL__ "${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}" <<-END_OF_TEXT
			#
			#   o p t i o n s
			#
			# verbose mode, allowed values are:
			#   'extended', 2
			#   'true', 't', 'yes', 'y', 'set', 'ok', 'on', 'simple', 1
			#   'false', 'f', 'no', 'n', 'none', 'notset', 'clean', 'off', 0
			#verbose:         false
			#
			# abbreviation length
			# if not set, assumes 8 characters
			#abbrev:          8
			#
			# leading text before version identifier; for example VERSION_TEXT becomes LEADER_VERSION_TEXT
			$([ -z "${VERSION_LEADER}" ] && echo "#leader:          XXX_" || echo "leader:           ${VERSION_LEADER}")
			#
			# trailing text after version identifier; for example VERSION_TEXT becomes VERSION_TEXT_TRAILER
			#trailer:         _XXX
			#
			# the company/person title
			# if not set, then used:
			# a) under Windows - 'HKLM\Software\Microsoft\WIndows NT\registered organization';
			# b) under Linux - username;
			# c) otherwise 'Unknown Author' will be assumed.
			authorship:       ${VERSION_AUTHORSHIP:-Unknown Author}
			# note: edit if not ok and uncomment; this will speed-up the process a little
			#
			# the copyright/copyleft declaration
			# if not set, then 'DEFAULT_DECL AUTHORSHIP YEAR' is used:
			#    DEFAULT_DECL is set by the 'STAMPER_DEFAULT_DECL' parameter of the file ${STAMPER_SCRIPT_NAME}-config;
			#    AUTHORSHIP is specified by the 'authorship:' parameter above;
			#    YEAR is the current year or year of initial commit.
			declaration:      ${VERSION_DECLARATION:-${STAMPER_DEFAULT_DECL} your name initial_year}
			# note: avoid to use localized and special characters here
			#
			# activate hooks
			# available hooks are:  pre-commit  post-commit  post-checkout  post-rewrite  post-merge
			$([ -n "${VERSION_CONFIG_PREFIX}" ] && echo "# ")hooks:           ${!STAMPER_HOOKS[@]}
			# note: if pre-commit is used then post-commit is useless
			#
			# the default command
			# it will be used if stamper is running without argumentss (if not set, --help is ssumed)
			default-cmd:     --list --print
			#
			# the version textoize script
			# it will be used to build VERSION_TEXT using other VERSION_* variables
			# if not set, then use hardcoded v0.0.0-branch+ form, otherwise you may choose
			# one of$(for f in ${STAMPER_SCRIPT_PATH}-textoize-*; do f=${f##*/}; echo -n " '${f#*-textoize-}'"; done)
			#textoize:        default

			#   p l u g i n s
			#
			# plugin-NAME: [options] path
			#    where
			#        path                     is a repository-relative path to target version file
			#        -i    --gitignore        add version file into .gitignore
			#        -a    --gitattributes    add version file into .gitattributes (useless if version file is gitignored)
			#                                 --gitignore and --gitattributes are used when creating a new file.
			#        --leader string          assign specific leader string
			#        --trailer string         assign specific trailer string
			#
			$(for plugin in "${!STAMPER_PLUGINS[@]}"; do __PLUGIN_${plugin}_SAMPLE__; done)

			#   t h e   e n d
		END_OF_TEXT
		__VERBOSE__ ".   git add --force -- \"${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}\""
		git --no-pager add --force -- "${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}" >/dev/null
		# add config into .gitattributes
		STAMPER_FILL_ATTRIB["${VERSION_CONFIG_PREFIX}${VERSION_CONFIG_NAME}"]="text"
	fi
fi

if [[ "true" == ${STAMPER_DO_PRINT_INFO} || "true" == ${STAMPER_GENERATE} ]]; then
	#
	# get build host and OS identification
	#
	VERSION_HOSTINFO="${USER:-$USERNAME}"
	VERSION_HOSTINFO="${VERSION_HOSTINFO//\\//}"
	__VERBOSE__ "Build VERSION_HOSTINFO description\n.   user=\"${VERSION_HOSTINFO}\""
	temp="${HOSTNAME:-$(hostname 2>/dev/null)}"
	temp="${temp:-localhost}"
	__VERBOSE__ ".   host=\"$temp\""
	VERSION_HOSTINFO="${VERSION_HOSTINFO}@${temp}"
	temp=""
	if [[ "Windows_NT" == ${OS} ]]; then
		util="$(which reg.exe 2>/dev/null)"
		if [[ -n ${util} ]]; then
			temp=$(MSYS_NO_PATHCONV=1 "${util}" query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion" /t REG_SZ 2>/dev/null \
					| awk -v RS='(\r\n|\n\r|\r|\n)' '/^\s*ProductName/ { w=""; for ( i=3; i<=NF; i++ ) w = w $i " "; }
						   /^\s*CSDVersion/ { s=""; for ( i=3; i<=NF; i++ ) s = s $i " "; }
						   /^\s*CurrentBuildx\s/ { b=""; for ( i=3; i<=NF; i++ ) b=b $i " "; }
						   END{ print gensub( "\\s+$", "", 1, b != "" ? w s "Build " b : w s ); }')
			__VERBOSE__ ".   this is windows; try \"$util\" to get os identification\n.      \"$temp\""
		fi
	else
		util="$(which lsb_release 2>/dev/null)"
		if [[ -n ${util} ]]; then
			temp=$("${util}" -d -s |sed -r -e 's/"//g')
			__VERBOSE__ ".   this is *nix; try \"$util\" to get os identification\n.      \"$temp\""
		fi
		if [[ -z ${temp} && -f /etc/os-release ]]; then
			temp="$(cat "/etc/os-release" \
					| awk -v RS='(\r\n|\n\r|\r|\n)' -v FS==  '$1 == "PRETTY_NAME" { pn=$2; }
									$1 == "NAME" { n=$2; }
									$1 == "VERSION" { v=$2; }
									END{ print gensub( "\"", "", "G", pn == "" ? n " " v : pn ); }')"
			__VERBOSE__ ".   this is *nix; try \"/etc/os-release\" to get os identification\n.      \"$temp\""
		fi
		if [[ -z ${temp} ]]; then
			util="$(which hostnamectl 2>/dev/null)"
			if [[ -n ${util} ]]; then
				temp="$(hostnamectl status |awk -v RS='(\r\n|\n\r|\r|\n)' 'match( $0, /^\s*Operating\s+System:\s+(.*)$/, A ) { print A[1]; }')"
				__VERBOSE__ ".   this is *nix; try \"$util\" to get os identification\n.      \"$temp\""
			fi
		fi
	fi
	if [[ -z ${temp} ]]; then
		util="$(which uname 2>/dev/null)"
		if [[ -n ${util} ]]; then
			temp="$("${util}" -s)"
			__VERBOSE__ ".   try \"$util\" to get os identification\n.      \"$temp\""
		fi
	fi
	if [[ -n ${temp} ]]; then
		VERSION_HOSTINFO="${VERSION_HOSTINFO} ${temp}"
		__VERBOSE__ ".   VERSION_HOSTINFO=\"${VERSION_HOSTINFO}\""
	fi
	unset temp
	unset util
	
	if [[ "0000000000000000000000000000000000000000" == ${VERSION_SHA_LONG} ]]; then
		VERSION_COMMIT_AUTHOR="${VERSION_GIT_USER}"
		VERSION_COMMIT_EMAIL="${VERSION_GIT_EMAIL}"
	else
		eval $(git show --no-notes --no-patch --pretty=format:"VERSION_COMMIT_AUTHOR='%aN'%nVERSION_COMMIT_EMAIL='%ae'%n")
		__VERBOSE__ "git show --no-notes --no-patch --pretty=format:\"...\"\n.   VERSION_COMMIT_AUTHOR=${VERSION_COMMIT_AUTHOR}\n.   VERSION_COMMIT_EMAIL=${VERSION_COMMIT_EMAIL}"
		if [[ -z ${VERSION_COMMIT_AUTHOR} ]]; then
			VERSION_COMMIT_AUTHOR="${VERSION_GIT_USER}"
			VERSION_COMMIT_EMAIL="${VERSION_GIT_EMAIL}"
		fi
	fi
fi

if [[ "true" == ${STAMPER_DO_PRINT_INFO} ]]; then
	echo "${VERSION_TEXT}  ${VERSION_DATE}  ${VERSION_HOSTINFO}"
	echo "   VERSION_ID=            ${VERSION_ID}"
	echo "   VERSION_TEXT=          ${VERSION_TEXT}"
	echo "   VERSION_PREFIX=        ${VERSION_PREFIX}"
	echo "   VERSION_MAJOR=         ${VERSION_MAJOR}"
	echo "   VERSION_MINOR=         ${VERSION_MINOR}"
	echo "   VERSION_SUFFIX=        ${VERSION_SUFFIX}"
	echo "   VERSION_BUILD=         ${VERSION_BUILD}"
	echo "   VERSION_BRANCH=        ${VERSION_BRANCH}"
	echo "   VERSION_DIRTY=         ${VERSION_DIRTY}"
	echo "   VERSION_DATE=          ${VERSION_DATE}"
	echo "   VERSION_SHORTDATE=     ${VERSION_SHORTDATE}"
	echo "   VERSION_UNIXTIME=      ${VERSION_UNIXTIME}"
	echo "   VERSION_SHA_LONG=      ${VERSION_SHA_LONG}"
	echo "   VERSION_SHA_SHORT=     ${VERSION_SHA_SHORT}"
	echo "   VERSION_HOSTINFO=      ${VERSION_HOSTINFO}"
	echo "   VERSION_AUTHORSHIP=    ${VERSION_AUTHORSHIP}"
	echo "   VERSION_DECLARATION=   ${VERSION_DECLARATION}"
	echo "   VERSION_SUBMOD_NAME=   ${VERSION_SUBMOD_NAME}"
	echo "   VERSION_SUBMOD_PATH=   ${VERSION_SUBMOD_PATH}"
	echo "   VERSION_COMMIT_AUTHOR= ${VERSION_COMMIT_AUTHOR}"
	echo "   VERSION_COMMIT_EMAIL=  ${VERSION_COMMIT_EMAIL}"
	echo "   VERSION_LEADER=        ${VERSION_LEADER}"
	echo "   VERSION_TRAILER=       ${VERSION_TRAILER}"
	echo "   Note. The identifier names listed here are exposed in the plugin, not in the target file."
fi

if [[ "true" == ${STAMPER_GENERATE} ]]; then
	__AS_PREPARED_VALUES__ VERSION_TEXT "${VERSION_TEXT}"
	__AS_PREPARED_VALUES__ VERSION_BRANCH "${VERSION_BRANCH}"
	__AS_PREPARED_VALUES__ VERSION_DIRTY "${VERSION_DIRTY}"
	__AS_PREPARED_VALUES__ VERSION_DATE "${VERSION_DATE}"
	__AS_PREPARED_VALUES__ VERSION_HOSTINFO "${VERSION_HOSTINFO}"
	__AS_PREPARED_VALUES__ VERSION_AUTHORSHIP "${VERSION_AUTHORSHIP}"
	__AS_PREPARED_VALUES__ VERSION_DECLARATION "${VERSION_DECLARATION}"
	__AS_PREPARED_VALUES__ VERSION_SUBMOD_NAME "${VERSION_SUBMOD_NAME}"
	__AS_PREPARED_VALUES__ VERSION_SUBMOD_PATH "${VERSION_SUBMOD_PATH}"
	__AS_PREPARED_VALUES__ VERSION_COMMIT_AUTHOR "${VERSION_COMMIT_AUTHOR}"
	__AS_PREPARED_VALUES__ VERSION_COMMIT_EMAIL "${VERSION_COMMIT_EMAIL}"

	__VERBOSE__ "\nRun all configured plugins"
	for index in "${!STAMPER_EXEC_PLUGIN[@]}"; do
		plugin="${STAMPER_EXEC_PLUGIN[${index}]}"
		target="${STAMPER_EXEC_TARGET[${index}]}"

		NAME_VERSION_LEADER="${STAMPER_EXEC_LEADER[${index}]:-${VERSION_LEADER}}"
		NAME_VERSION_TRAILER="${STAMPER_EXEC_TRAILER[${index}]:-${VERSION_TRAILER}}"
		NAME_VERSION_ID="${NAME_VERSION_LEADER}VERSION_ID${NAME_VERSION_TRAILER}"
		NAME_VERSION_TEXT="${NAME_VERSION_LEADER}VERSION_TEXT${NAME_VERSION_TRAILER}"
		NAME_VERSION_PREFIX="${NAME_VERSION_LEADER}VERSION_PREFIX${NAME_VERSION_TRAILER}"
		NAME_VERSION_MAJOR="${NAME_VERSION_LEADER}VERSION_MAJOR${NAME_VERSION_TRAILER}"
		NAME_VERSION_MINOR="${NAME_VERSION_LEADER}VERSION_MINOR${NAME_VERSION_TRAILER}"
		NAME_VERSION_SUFFIX="${NAME_VERSION_LEADER}VERSION_SUFFIX${NAME_VERSION_TRAILER}"
		NAME_VERSION_BUILD="${NAME_VERSION_LEADER}VERSION_BUILD${NAME_VERSION_TRAILER}"
		NAME_VERSION_BRANCH="${NAME_VERSION_LEADER}VERSION_BRANCH${NAME_VERSION_TRAILER}"
		NAME_VERSION_DIRTY="${NAME_VERSION_LEADER}VERSION_DIRTY${NAME_VERSION_TRAILER}"
		NAME_VERSION_DATE="${NAME_VERSION_LEADER}VERSION_DATE${NAME_VERSION_TRAILER}"
		NAME_VERSION_SHORTDATE="${NAME_VERSION_LEADER}VERSION_SHORTDATE${NAME_VERSION_TRAILER}"
		NAME_VERSION_UNIXTIME="${NAME_VERSION_LEADER}VERSION_UNIXTIME${NAME_VERSION_TRAILER}"
		NAME_VERSION_SHA_LONG="${NAME_VERSION_LEADER}VERSION_SHA_LONG${NAME_VERSION_TRAILER}"
		NAME_VERSION_SHA_SHORT="${NAME_VERSION_LEADER}VERSION_SHA_SHORT${NAME_VERSION_TRAILER}"
		NAME_VERSION_HOSTINFO="${NAME_VERSION_LEADER}VERSION_HOSTINFO${NAME_VERSION_TRAILER}"
		NAME_VERSION_AUTHORSHIP="${NAME_VERSION_LEADER}VERSION_AUTHORSHIP${NAME_VERSION_TRAILER}"
		NAME_VERSION_DECLARATION="${NAME_VERSION_LEADER}VERSION_DECLARATION${NAME_VERSION_TRAILER}"
		NAME_VERSION_SUBMOD_NAME="${NAME_VERSION_LEADER}VERSION_SUBMOD_NAME${NAME_VERSION_TRAILER}"
		NAME_VERSION_SUBMOD_PATH="${NAME_VERSION_LEADER}VERSION_SUBMOD_PATH${NAME_VERSION_TRAILER}"
		NAME_VERSION_COMMIT_AUTHOR="${NAME_VERSION_LEADER}VERSION_COMMIT_AUTHOR${NAME_VERSION_TRAILER}"
		NAME_VERSION_COMMIT_EMAIL="${NAME_VERSION_LEADER}VERSION_COMMIT_EMAIL${NAME_VERSION_TRAILER}"

		case "${target}" in
		//- | //-- | /* | ?:/*)
			# do not prefix reserved names and absolute pathes
			;;
		../*)
			__STDPATH_FUNCTION__ --var=target --base="${VERSION_ROOT_DIR}" --directory="${VERSION_ROOT_DIR}" -- "${VERSION_CONFIG_PREFIX}${target}"
			;;
		*)
			target="${VERSION_CONFIG_PREFIX}${target}"
			;;
		esac

		__VERBOSE__ "\n+ Use \"${plugin}\" with \"${target}\"; try to read it"
		case "${target}" in
		//-)
			indata=""
			;;
		//--)
			__VERBOSE__ "Waiting incoming version stamp on stdin..."
			indata="$(cat)"
			;;
		*)
			indata="$(__READ_LF__ "${target}")"
			;;
		esac
		if [[ -n ${indata} ]]; then
			__VERBOSE__ ".      was read ${#indata} bytes\n.   check version of file \"${target}\" using __PLUGIN_${plugin}_GETVER__"
			existing_version="$(__PLUGIN_${plugin}_GETVER__ <<<"${indata}")"

			if [[ ${existing_version} == ${VERSION_TEXT} && -z ${VERSION_DIRTY} ]]; then
				__VERBOSE__ ".   NOW \"$existing_version\" is same as generated \"${VERSION_TEXT}\" REMAIN UNCHANGED \"${target}\""
			else
				# generate new file 1) if versions mismatch and/or 2) if dirty flag set because 'date of sources' will be changed every time
				__VERBOSE__ ".   update existing file \"${target}\" (\"$existing_version\" => \"${VERSION_TEXT}\") using __PLUGIN_${plugin}_MODIFY__"
				__PLUGIN_${plugin}_MODIFY__ "${target}" <<<"${indata}"
				# file was changed?
				case "${target}" in
				//- | //--)
					outdata="_${indata}_"
					;;
				*)
					outdata="$(__READ_LF__ "${target}")"
					;;
				esac
				if [[ ${indata} == ${outdata} ]]; then
					__VERBOSE__ "-------------------------------------------------"
					echo "WARNING: Plugin \"$plugin\" did not modify \"${target}\"" 1>&2
					echo "         This occurs if version script cannot lookup *VERSION_* data" 1>&2
					echo "         (for example: changed leader or trailer); remove target file(s)" 1>&2
					echo "         before or rename old identifiers manually." 1>&2
				else
					case "${target}" in
					/* | ?:/* | ../*)
						# outside of tree or special target (//- //--), do nothing
						;;
					*)
						# detect .gitignore'd state by fact, do not rely on ${STAMPER_EXEC_IGNORE[${index}]} data (they may be changed or lost)
						__VERBOSE__ "git check-ignore -- \":/:${target}\""
						if [[ -z $(git --no-pager check-ignore -- ":/:${target}" 2>/dev/null) ]]; then
							__VERBOSE__ ".    NON-GITIGNORED file\ngit add \":/:${target}\""
							git --no-pager add --force -- ":/:${target}" >/dev/null
						else
							__VERBOSE__ ".    is GITIGNORED file -- do not add into repo"
						fi
						;;
					esac
				fi
			fi
		else
			__VERBOSE__ ".      was read ${#indata} bytes\n.   (re)create new file \"${target}\" using __PLUGIN_${plugin}_CREATE__"
			__PLUGIN_${plugin}_CREATE__ "${target}"
			case "${target}" in
			/* | ?:/* | ../*)
				# special names //-, //-- or outside of tree, nothing
				__VERBOSE__ ".      skip gitignore/gitattributes for external file \"${target}\""
				;;
			*)
				# update .gitattributes on creation target file
				[[ "true" == ${STAMPER_EXEC_ATTRIB[${index}]} ]] && STAMPER_FILL_ATTRIB[${target}]="$(__PLUGIN_${plugin}_ATTRIB__)"
				# update .gitignore on creation target file
				if [[ "true" == ${STAMPER_EXEC_IGNORE[${index}]} ]]; then
					# check .gitignore content later
					STAMPER_FILL_IGNORE[${#STAMPER_FILL_IGNORE[@]}]="${target}"
				else
					# check .gitignore'd state by fact, do not rely on ${STAMPER_EXEC_IGNORE[${index}]} data (they may be changed or lost)
					__VERBOSE__ "git check-ignore -- \":/:${target}\""
					if [[ -z $(git --no-pager check-ignore -- ":/:${target}" 2>/dev/null) ]]; then
						__VERBOSE__ ".    NON-GITIGNORED file\ngit add \":/:${target}\""
						git --no-pager add --force -- ":/:${target}" >/dev/null
					else
						__VERBOSE__ ".    is GITIGNORED file -- do not add into repo"
					fi
				fi
				;;
			esac
		fi
		unset indata
		unset outdata
		unset target
		unset plugin
	done
	__VERBOSE__ "\n"
fi

if [[ "true" == ${STAMPER_DO_LIST_PLUGINS} ]]; then
	# list after generation, file data may be changed
	echo "Folders:"
	echo "   VERSION_SUPER_DIR=     ${VERSION_SUPER_DIR}"
	echo "   VERSION_CURRENT_DIR=   ${VERSION_CURRENT_DIR}"
	echo "   VERSION_ROOT_DIR=      ${VERSION_ROOT_DIR}"
	echo "   VERSION_CONFIG_PREFIX= ${VERSION_CONFIG_PREFIX}"
	echo "   VERSION_CONFIG_NAME=   ${VERSION_CONFIG_NAME}"
	echo "   VERSION_GIT_DIR=       ${VERSION_GIT_DIR}"
	echo "   VERSION_HOOKS_DIR=     ${VERSION_HOOKS_DIR:-(not found)}"
	echo ""

	declare -A temp_plugin
	declare -A temp_ignore
	declare -A temp_attrib
	declare -A temp_source
	declare -A temp_leader
	declare -A temp_trailer
	for n in "${!STAMPER_EXEC_PLUGIN[@]}"; do
		target="${STAMPER_EXEC_TARGET[${n}]}"
		temp_plugin[${target}]="${STAMPER_EXEC_PLUGIN[${n}]}"
		temp_ignore[${target}]="${STAMPER_EXEC_IGNORE[${n}]}"
		temp_attrib[${target}]="${STAMPER_EXEC_ATTRIB[${n}]}"
		temp_leader[${target}]="${STAMPER_EXEC_LEADER[${n}]}"
		temp_trailer[${target}]="${STAMPER_EXEC_TRAILER[${n}]}"
		temp_source[${target}]="cmd"
	done
	# STAMPER_EXEC_* and STAMPER_CONF_* are combined into STAMPER_EXEC_* only if stamps generation is done;
	# so check here for runs without generation.
	for n in ${!STAMPER_CONF_PLUGIN[@]}; do
		target="${STAMPER_CONF_TARGET[${n}]}"
		[[ -z ${temp_plugin[${target}]} ]] && temp_source["${target}"]="config" || temp_source["${target}"]="config, ${temp_source[${target}]}"
		# config has precedence over command line
		temp_plugin[${target}]="${STAMPER_CONF_PLUGIN[${n}]}"
		temp_ignore[${target}]="${STAMPER_CONF_IGNORE[${n}]}"
		temp_attrib[${target}]="${STAMPER_CONF_ATTRIB[${n}]}"
		temp_leader[${target}]="${STAMPER_CONF_LEADER[${n}]}"
		temp_trailer[${target}]="${STAMPER_CONF_TRAILER[${n}]}"
	done

	plen=$(__maxlen__ "Plugin" "${!STAMPER_PLUGINS[@]}")
	flen=$(__maxlen__ "Target file" "${!temp_plugin[@]}")
	__triple_echo__ $plen "Plugin" $flen "Target file" "Information"
	echo "--------------------------------------------------------------------------"
	for plugin in "${!STAMPER_PLUGINS[@]}"; do
		empty="true"
		for target in "${!temp_plugin[@]}"; do
			if [[ ${plugin} == ${temp_plugin[${target}]} ]]; then
				if [[ -n ${target} ]]; then
					empty="false"
					if [[ ! -f ${VERSION_CONFIG_DIR}/${target} ]]; then
						info="fs: NONE"
					else
						info="fs: len=$(ls -l --time-style="+%Y-%m-%d %H:%M:%S" "${VERSION_CONFIG_DIR}/${target}" |cut -d " " -f 5-7)"
					fi

					git_info="$(git --no-pager log -n 1 --date="format:%Y-%m-%d %H:%M:%S" --format="%ad @%h" -- "${VERSION_CONFIG_PREFIX}${target}" 2>/dev/null)"
					[[ -n ${git_info} ]] && info="git: ${git_info}, ${info}"
					[[ "true" == ${temp_ignore[${target}]} ]] && info=".gitignore, ${info}"
					[[ "true" == ${temp_attrib[${target}]} ]] && info="$(__PLUGIN_${temp_plugin[${target}]}_ATTRIB__), ${info}"
					[[ -n ${temp_trailer[${target}]} ]] && infp="--temp_trailer=\"${temp_trailer[${target}]}\", ${info}"
					[[ -n ${temp_leader[${target}]} ]] && infp="--leader=\"${temp_leader[${target}]}\", ${info}"
					__triple_echo__ $plen "${plugin}" $flen "${target}" "${temp_source[${target}]}, ${info}"
					unset git_info
				fi
			fi
		done
		if [[ "true" == ${empty} ]]; then
			__triple_echo__ $plen "$plugin" $flen "-" "Not configured"
		fi
		unset target
		unset plugin
	done
	unset empty
	unset info
	unset plen
	unset flen
	unset temp_plugin
	unset temp_ignore
	unset temp_attrib
	unset temp_source
	unset temp_leader
	unset temp_trailer
fi

#
# check/update .gitignore and/or .gitattributes
#
if [[ 0 -ne ${#STAMPER_FILL_ATTRIB[@]} ]]; then
	declare -i n
	r=""

	script="BEGIN {"
	n=0; for f in "${!STAMPER_FILL_ATTRIB[@]}"; do
		((n=n+1))
		script="${script}
    F${n} = 0;"
    done
	script="${script}
}"
	n=0; for f in "${!STAMPER_FILL_ATTRIB[@]}"; do
		((n=n+1))
		A="${STAMPER_FILL_ATTRIB[${f}]}"
		__STDPATH_FUNCTION__ -v=f --base "${VERSION_CONFIG_DIR}" -- "${VERSION_ROOT_DIR}/${f}"
		__AS_REGEX_IN__ r "${f}"
		script="${script}
/^\\s*#\\s*${r}\\s+/ {
    if ( 0 == F${n} ) { F${n} = 1; print \"${f// /\\\\\\ }   ${A}\"; }
	next;
}
/^\\s*${r}\\s+/ {
    if ( 0 == F${n} ) {
        for ( i = 2; i <= NF; i++ ) if ( \"$A\" == \$i ) F${n} = 1;
        if ( 0 == F$n ) { F${n} = 1; print \"${f// /\\\\\\ }   ${A}\"; } else { print; }
    }
    next;
}"
	done
	script="${script}
    { print; }
END {"
	n=0; for f in "${!STAMPER_FILL_ATTRIB[@]}"; do
		((n=n+1))
		A="${STAMPER_FILL_ATTRIB[${f}]}"
		__STDPATH_FUNCTION__ -v=f --base "${VERSION_CONFIG_DIR}" -- "${VERSION_ROOT_DIR}/${f}"
		script="${script}
    if ( F${n} == 0 ) print \"${f// /\\\\\\ }   ${A}\";"
	done
	script="${script}
}"
__VERBOSE__ "${script}"
	unset r n f

	text_a="$(__READ_LF__ "${VERSION_CONFIG_PREFIX}.gitattributes")"
	[[ -z ${text_a} ]] && text_a="#
# text=true   text    assume tex file, allow CRLF translation (CRLF to LF on worktree->repo, LF to CRLF on repo->worktree)
# text=false  -text   assume binary file, disable CRLF translation
# text=auto           try to detect type of file and apply tetx/binary rules depend on its content
# <text is missing>   use core.autocrlf
#    the eol=... needs in text or text=true or text=auto before ('text eol=crlf' or 'text eol=lf')
#    without 'text' it depends on 'core.crlf' configuration, so it vary one machine to another
# eol=crlf            force CRLF translation (CRLF in worktree, LF in git)
# eol=lf              replace CRLF with LF on worktree->repo, do nothing on repo->worktree
# ---
# crlf        text    old-style crlf option
# -crlf       -text   ---------
# crlf=input  eol=lf  ---------
#
.gitignore      text eol=lf
.gitattributes  text eol=lf
.gitmodules     text eol=lf"
	text_b="$(awk -v RS='(\r\n|\n\r|\r|\n)' -e "${script}" <<<"${text_a}")"
	if [[ ${text_a} != ${text_b} ]]; then
		__VERBOSE__ ".   update .gitattributes\n.   git add --force ${VERSION_CONFIG_PREFIX}.gitattributes"
		__STORE_LF__ "${VERSION_CONFIG_PREFIX}.gitattributes" <<<"${text_b}"
		git --no-pager add --force -- "${VERSION_CONFIG_PREFIX}.gitattributes" >/dev/null
	else
		__VERBOSE__ ".   OK .gitattributes, use it as-is"
	fi
	unset text_b
	unset text_a
	unset script
fi

if [[ 0 != ${#STAMPER_FILL_IGNORE[@]} ]]; then
	r=""
	script="BEGIN {"
	for n in "${!STAMPER_FILL_IGNORE[@]}"; do
		script="${script}
    F${n} = 0;"
    done
	script="${script}
}"
	for n in "${!STAMPER_FILL_IGNORE[@]}"; do
		f="${STAMPER_FILL_IGNORE[${n}]}"
		__STDPATH_FUNCTION__ -v=f --base "${VERSION_CONFIG_DIR}" -- "${VERSION_ROOT_DIR}/${f}"
		__AS_REGEX_IN__ r "${f}"
		script="${script}
/^\\s*#\\s*${r}\\s*\$/ {
    if ( 0 == F${n} ) { F${n} = 1; print \"${f// /\\\\\\ }\"; }
    next;
}
/^\\s*${r}\\s*\$/ {
    if ( 0 == F${n} ) { F${n} = 1; print; }
    next;
}"
	done
	script="${script}
    { print; }
END {"
	for n in "${!STAMPER_FILL_IGNORE[@]}"; do
		f="${STAMPER_FILL_IGNORE[${n}]}"
		__STDPATH_FUNCTION__ -v=f --base "${VERSION_CONFIG_DIR}" -- "${VERSION_ROOT_DIR}/${f}"
		script="${script}
    if ( F${n} == 0 ) print \"${f// /\\\\\\ }\";"
	done
	script="${script}
}"
	unset r n f
__VERBOSE__ "${script}"

	text_a="$(__READ_LF__ "${VERSION_CONFIG_PREFIX}.gitignore")"
	if [[ -z ${text_a} ]]; then
			text_a="#
# temporary, intermediate and target files
*.meta
*.tmp
*.log
*.lst
*.obj
*.o
*.i
*.d
*.map
*.pyc

# target files
*.elf
*.exe
*.so
*.dll
*.jar

# backup files
*.bak
*.autosave
*.asv
~*
*~

# local settings
*.ini
*.conf

# traditional build results
_[Bb][Ii][Nn]/

# private files (are out of repo)
_[Pp][Rr][Ii][Vv][Aa][Tt][Ee]/"
		if [[ "Windows_NT" == ${OS} ]]; then
			text_a="${text_a}

# Ignore Visual Studio temporary files, build results, and
# files generated by popular Visual Studio add-ons.
#
# User-specific files
*.suo
*.user
*.sln.docstates
*.resources
*.editorconfig

# Build results
*.res

# Studio working files
.vs/

# Enable \"build/\" folder in the NuGet Packages folder since NuGet packages use it for MSBuild targets
!packages/*/build/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

*_i.c
*_p.c
*.ilk
*.pch
*.pdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp_proj
*.vspscc
*.vssscc
.builds
*.pidb
*.scc

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opensdf
*.sdf
*.cachefile

# Visual Studio profiler
*.psess
*.vsp
*.vspx

# Guidance Automation Toolkit
*.gp[Ss]tate

# ReSharper is a .NET coding add-in
_[Rr]e[Ss]harper*/
*.[Rr]e[Ss]harper

# TeamCity is a build add-in
_[Tt]eam[Cc]ity*

# DotCover is a Code Coverage Tool
*.dot[Cc]over

# NCrunch
*.ncrunch*
.*crunch*.local.xml

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
[Dd]oc[Pp]roject/buildhelp/
[Dd]oc[Pp]roject/[Hh]elp/*.[Hh]x[Tt]
[Dd]oc[Pp]roject/[Hh]elp/*.[Hh]x[Cc]
[Dd]oc[Pp]roject/[Hh]elp/*.hhc
[Dd]oc[Pp]roject/[Hh]elp/*.hhk
[Dd]oc[Pp]roject/[Hh]elp/*.hhp
[Dd]oc[Pp]roject/[Hh]elp/[Hh]tml2
[Dd]oc[Pp]roject/[Hh]elp/[Hh]tml

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml

# NuGet Packages Directory
#packages/

# Windows Azure Build Output
csx
*.build.csdef

# Windows Store app package directory
[Aa]pp[Pp]ackages/

# Others
sql/
*.[Cc]ache
[Cc]lientBin/
[Ss]tyle[Cc]op.*
~\$*
*.dbmdl
*.[Pp]ublish.xml
*.pfx
*.publishsettings

# RIA/Silverlight projects
[Gg]enerated_[Cc]ode/

# Backup & report files from converting an old project file to a newer
# Visual Studio version. Backup files are not needed, because we have git ;-)
_[Uu]pgrade[Rr]eport_[Ff]iles/
[Bb]ackup*/
[Uu]pgrade[Ll]og*.[Xx][Mm][Ll]
[Uu]pgrade[Ll]og*.htm

# SQL Server files
[Aa]pp_[Dd]ata/*.mdf
[Aa]pp_[Dd]ata/*.ldf

# LightSwitch generated files
[Gg]enerated[Aa]rtifacts/
_[Pp]vt_[Ee]xtensions/
[Mm]odel[Mm]anifest.xml

# Windows image file caches
[Tt]humbs.db
ehthumbs.db

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
\$[Rr][Ee][Cc][Yy][Cc][Ll][Ee].[Bb][Ii][Nn]/

# Mac desktop service store files
.[Dd][Ss]_[Ss]tore"
		fi
	fi

	text_b="$(awk -v RS='(\r\n|\n\r|\r|\n)' -e "${script}" <<<"${text_a}")"
	if [[ ${text_a} != ${text_b} ]]; then
		__VERBOSE__ ".   update .gitignore\n.   git add --force ${VERSION_CONFIG_PREFIX}.gitignore"
		__STORE_LF__ "${VERSION_CONFIG_PREFIX}.gitignore" <<<"${text_b}"
		git --no-pager add --force -- "${VERSION_CONFIG_PREFIX}.gitignore" >/dev/null
	else
		__VERBOSE__ ".   OK .gitignore, use it as-is"
	fi
	unset text_b
	unset text_a
	unset script
fi

#
# setup or delete given hook
#
function __update_this_hook_really__
{
	local 	hook_action="$1"
	local 	hook="$2"
	local	hook_path="$3"
	local	description="$4"

	case "${hook_action}" in
	remove)
		__VERBOSE__ ".   rm -f -- \"${hook_path}\"    ${description}"
		rm -f -- "${hook_path}"
		;;
	setup)
		__VERBOSE__ ".   store \"${hook}\"    ${description}"
		case "${hook}" in
		pre-commit)
			echo "#!/bin/sh
# +--------------------------------------------------------------------+
# | This Source Code Form is subject to the terms of the Mozilla       |
# | Public License, v. 2.0. If a copy of the MPL was not distributed   |
# | with this file, You can obtain one at http://mozilla.org/MPL/2.0/. |
# +--------------------------------------------------------------------+
#
# This hook script is called by 'git commit' with no arguments.
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.

export STAMPER_SUITE=\"Version suite ${STAMPER_VERSION_TEXT}\"
# note: the STAMPER_SUITE is a signature of script; setup will detect it as part of version suite using given text
#

if [[ -x \"${STAMPER_SCRIPT_CMD}\" ]]; then
	\"${STAMPER_SCRIPT_CMD}\" --git-hook=pre-commit --generate
	exit \$?
fi
exit 0
" >"${hook_path}"
			__CHMOD__ a+x "${hook_path}"
			;;
		post-checkout)
			echo "#!/bin/sh
# +--------------------------------------------------------------------+
# | This Source Code Form is subject to the terms of the Mozilla       |
# | Public License, v. 2.0. If a copy of the MPL was not distributed   |
# | with this file, You can obtain one at http://mozilla.org/MPL/2.0/. |
# +--------------------------------------------------------------------+
#
# This hook is invoked when a 'git checkout' or 'git switch' is run after having updated the worktree.
# It is also run after 'git clone' and 'git worktree add', unless the --no-checkout (-n) option is used.
# The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which
# may or may not have changed), and a flag indicating whether the checkout was a branch checkout
# (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0)

export STAMPER_SUITE=\"Version suite ${STAMPER_VERSION_TEXT}\"
# note: the STAMPER_SUITE is a signature of script; setup will detect it as part of version suite using given text
#

if [[ \$3 == \"1\" && -z \${GIT_REFLOG_ACTION} ]]; then
	if [[ -x \"${STAMPER_SCRIPT_CMD}\" ]]; then
		\"${STAMPER_SCRIPT_CMD}\" --git-hook=post-checkout --generate
		exit \$?
	fi
fi
exit 0
" >"${hook_path}"
			__CHMOD__ a+x "${hook_path}"
			;;
		post-commit)
			echo "#!/bin/sh
# +--------------------------------------------------------------------+
# | This Source Code Form is subject to the terms of the Mozilla       |
# | Public License, v. 2.0. If a copy of the MPL was not distributed   |
# | with this file, You can obtain one at http://mozilla.org/MPL/2.0/. |
# +--------------------------------------------------------------------+
#
# This hook is invoked by git-commit. It takes no parameters, and is invoked
# after a commit is made.
# This hook is meant primarily for notification, and cannot affect the outcome of 'git commit'.
#
# GIT_REFLOG_ACTION is not set for simple an amend commits; it is set when post-commit
# is executed during merge, squash etc.

export STAMPER_SUITE=\"Version suite ${STAMPER_VERSION_TEXT}\"
# note: the STAMPER_SUITE is a signature of script; setup will detect it as part of version suite using given text
#

if [[ -z \${GIT_REFLOG_ACTION} ]]; then
	if [[ -x \"${STAMPER_SCRIPT_CMD}\" ]]; then
		VERSION_TEXT=\"\$(\"${STAMPER_SCRIPT_CMD}\" --git-hook=post-commit --generate)\"
		RETVAL=\$?
		if ! git --no-pager diff --cached --quiet >/dev/null 2>&1 ; then
			# there are some indexed changes, create new commit now
			git --no-pager -c core.hookspath=/dev/null commit --no-verify --amend --message \"\${VERSION_TEXT} \$(cat .git/COMMIT_EDITMSG 2>/dev/null |sed -e '/^\\s*#/d')\"
		fi
		exit \$RETVAL
	fi
fi
exit 0
" >"${hook_path}"
			__CHMOD__ a+x "${hook_path}"
			;;
		post-rewrite)
			echo "#!/bin/sh
# +--------------------------------------------------------------------+
# | This Source Code Form is subject to the terms of the Mozilla       |
# | Public License, v. 2.0. If a copy of the MPL was not distributed   |
# | with this file, You can obtain one at http://mozilla.org/MPL/2.0/. |
# +--------------------------------------------------------------------+
#
# This hook is invoked by commands that rewrite commits (git-commit when called
# with --amend and git-rebase; however, full-history (re)writing tools like
# git-fast-import or git-filter-repo typically do not call it!).
# Its first argument denotes the command it was invoked by: currently one of
# amend or rebase.
#

export STAMPER_SUITE=\"Version suite ${STAMPER_VERSION_TEXT}\"
# note: the STAMPER_SUITE is a signature of script; setup will detect it as part of version suite using given text
#

if [[ \${1,,} == \"rebase\" ]]; then
	if [[ -x \"${STAMPER_SCRIPT_CMD}\" ]]; then
		VERSION_TEXT=\"\$(\"${STAMPER_SCRIPT_CMD}\" --git-hook=post-rewrite --generate)\"
		RETVAL=\$?
		if ! git --no-pager diff --cached --quiet >/dev/null 2>&1 ; then
			# there are some indexed changes, create new commit now
			git --no-pager -c core.hookspath=/dev/null commit --no-verify --amend --message \"\${VERSION_TEXT} \$(cat .git/COMMIT_EDITMSG 2>/dev/null |sed -e '/^\\s*#/d')\"
		fi
		exit \$RETVAL
	fi
fi
exit 0
" >"${hook_path}"
			__CHMOD__ a+x "${hook_path}"
			;;
		post-merge)
			echo "#!/bin/sh
# +--------------------------------------------------------------------+
# | This Source Code Form is subject to the terms of the Mozilla       |
# | Public License, v. 2.0. If a copy of the MPL was not distributed   |
# | with this file, You can obtain one at http://mozilla.org/MPL/2.0/. |
# +--------------------------------------------------------------------+
#
# This hook is invoked by git-merge, which happens when a git pull is done on a
# local repository. The hook takes a single parameter, a status flag specifying
# whether or not the merge being done was a squash merge.
# This hook cannot affect the outcome of git merge and is not executed,
# if the merge failed due to conflicts.
#

export STAMPER_SUITE=\"Version suite ${STAMPER_VERSION_TEXT}\"
# note: the STAMPER_SUITE is a signature of script; setup will detect it as part of version suite using given text
#

VERSION_TEXT=\"\$([[ -x \"${STAMPER_SCRIPT_CMD}\" ]] && \"${STAMPER_SCRIPT_CMD}\" --git-hook=post-merge --generate || exit 1)\"
RETVAL=\$?
if [[ \"1\" != \$1 ]]; then
	# '\$1' == '1' means squash merge;
	# do not make commit for squash - it will be made manually later
	# (squash merge does not execute commit yet)
	if ! git --no-pager diff --cached --quiet >/dev/null 2>&1 ; then
		# there are some indexed changes, create new commit now
		git --no-pager -c core.hookspath=/dev/null commit --no-verify --amend --message \"\${VERSION_TEXT} \$(cat .git/MERGE_MSG 2>/dev/null |sed -e '/^\\s*#/d')\"
	fi
fi
exit \$RETVAL
" >"${hook_path}"
			__CHMOD__ a+x "${hook_path}"
			;;
		*)
			__VERBOSE__ ".   ERROR: UNSUPPORTED HOOK TYPE \"${hook}\" FOR \"${hook_path}\" ${description}"
			;;
		esac
			;;
	*)
		__VERBOSE__ ".   ERROR: UNSUPPORTED ACTION \"${hook_action}\" FOR \"${hook_path}\" ${description}"
		;;
	esac
}
#
# wait wuile parent ends and then execute setup/remove operation
#
function __update_this_hook_async__
{
	local	usleep="$(which usleep 2>/dev/null)"
	local	ps="$(which ps 2>/dev/null)"

	# stdout and stderr both are redirected, so change __VERBOSE__ to use logger 
	if [[ "Windows_NT" == ${OS} ]]; then
		# if stdout and stderr are closed ... I do'nt known how to
		# access windows syslog from msys2 bash script
		alias __VERBOSE__=__VERBOSE_OFF__
	else
		unalias __VERBOSE__
		function __VERBOSE__
		{
			[[ "off" != ${STAMPER_VERBOSE,,} ]] && __VERBOSE_${STAMPER_VERBOSE^^}__ "${STAMPER_EXECUTING_HOOK}: $*" 2>&1 | logger --id="${STAMPER_HOOK_PID}" --file /dev/stdin 1>/dev/null 2>&1
		}
	fi
	ps="${ps:-ps}"
	if [[ "Windows_NT" == ${OS} ]]; then
		case "${STAMPER_VERBOSE,,}" in
		simple | extended)
			# avoid complex string expansion using subshell execution if result is unused
			__VERBOSE__ "... Wait for pid $("${ps}" -s -p "${STAMPER_HOOK_PID}" |sed -n -e '/STIME/n;p')"
			;;
		esac
		while "${ps}" -p "${STAMPER_HOOK_PID}" >/dev/null 2>&1 && [ "0" == "${PIPESTATUS[0]}" ]; do
			# sleep 1 ms
			if [[ -n ${usleep} ]]; then
				"${usleep}" 1000
			else
				sleep 0.001s
			fi
		done
		case "${STAMPER_VERBOSE,,}" in
		simple | extended)
			# avoid complex string expansion using subshell execution if result is unused
			__VERBOSE__ "... Done waiting $("${ps}" -s -p "${STAMPER_HOOK_PID}" |sed -n -e '/STIME/n;p')"
			;;
		esac
	else
		case "${STAMPER_VERBOSE,,}" in
		simple | extended)
			# avoid complex string expansion using subshell execution if result is unused
			__VERBOSE__ "... Wait for pid $("${ps}" --no-headers -o pid,comm --pid "${STAMPER_HOOK_PID}")"
			;;
		esac
		while "${ps}" --pid "${STAMPER_HOOK_PID}" >/dev/null 2>&1 ; do
			# sleep 1 ms
			if [[ -n ${usleep} ]]; then
				"${usleep}" 1000
			else
				sleep 0.001s
			fi
		done
		case "${STAMPER_VERBOSE,,}" in
		simple | extended)
			# avoid complex string expansion using subshell execution if result is unused
			__VERBOSE__ "... Done waiting $("${ps}" --no-headers -o pid,comm --pid "${STAMPER_HOOK_PID}")"
			;;
		esac
	fi
	__update_this_hook_really__ "$1" "$2" "$3" "$4"
}
#
# update/remove hook inproc or async if hook is same as currently executed
#	__update_this_hook__ 1=action 2=hook 3=path 4=description
#
function __update_this_hook__
{
	if [[ $2 != ${STAMPER_EXECUTING_HOOK} ]]; then
		__update_this_hook_really__ "$1" "$2" "$3" "$4"
	else
		STAMPER_HOOK_PID=${PPID}
		__VERBOSE__ ".   delayed hook \"$2\" update after ending of running hook pid ${STAMPER_HOOK_PID}"
		# most of hooks terminates normally in parallel of async function execution
		# most .. not all
		# post-commit, for example, waits for releasing stdout and stderr channels
		# so we must execute async function within redirected output chennels
		export -f __CHMOD__
		__update_this_hook_async__ "$1" "$2" "$3" "$4" >/dev/null 2>&1 &
		#
		# note: nohup, disown does not resolve this trouble; they can detach current parent from async childs,
		# then parent termination will not terminate async childs. This is not our case: we are in child process
		# not parent, so these commands do not help us.
		# 	SEE MORE https://unix.stackexchange.com/questions/3886/difference-between-nohup-disown-and?newreg=7d90868c862743ef9ad5997c3150bde0
	fi
}
#
# scan existing and missing hooks and update them to current version
#
function __update_all_hooks__
{
	local -A	all_hooks
	local		hook_version
	local		hook_path
	local		hook

	all_hooks["pre-commit"]="${VERSION_HOOKS_DIR}/pre-commit"
	all_hooks["post-commit"]="${VERSION_HOOKS_DIR}/post-commit"
	all_hooks["post-rewrite"]="${VERSION_HOOKS_DIR}/post-rewrite"
	all_hooks["post-merge"]="${VERSION_HOOKS_DIR}/post-merge"
	all_hooks["post-checkout"]="${VERSION_HOOKS_DIR}/post-checkout"
	for hook_path in "${VERSION_HOOKS_DIR}"/*; do
		hook="${hook_path##*/}"
		case "${hook}" in
		#
		# pre-commit | post-checkout | post-commit | post-rewrite | post-merge)
		#	already in list
		#
		prepare-commit-msg | commit-msg | applypatch-msg | pre-applypatch | post-applypatch | pre-rebase | pre-push | pre-auto-gc | \
		pre-receive | update | post-receive | \
		fsmonitor-watchman | post-update)
			all_hooks["${hook}"]="${hook_path}"
			;;
		*)
			# do not add samples and others totally unknown stuffs
			;;
		esac
	done

	# all_hooks contains all existing hooks AND all our hooks for given stamper which may be missing
	for hook in "${!all_hooks[@]}"; do
		hook_path="${all_hooks[$hook]}"

		# try to get suite version
		if [[ -f ${hook_path} ]]; then
			# today 'stamper-'
			hook_version="$(head -n 128 "${hook_path}" \
					|awk -v RS='(\r\n|\n\r|\r|\n)' '
						match( $0, /^\s*export\s+STAMPER_SUITE=.*\s([A-Za-z][0-9]+[:._+-][0-9]+[:._+-][0-9]+[:._+-][[:graph:]]+)(\s|"|$)/, A ) { print "stamper-" A[1]; exit(0); }
						/export\s+STAMPER_SUITE=".*"/ { print "stamper-UNKNOWN"; exit(0); }
					')"
			if [[ -n ${hook_version} ]]; then
				__VERBOSE__ "Suite version of \"${hook}\" is \"${hook_version}\" (our is \"stamper-${STAMPER_VERSION_TEXT}\") -- this is known hook"
			else
				# hook_version is an empty string
				__VERBOSE__ "Suite version of \"${hook}\" is unknown -- this is not our hook"
			fi
		else
			hook_version="missing"
			__VERBOSE__ "Missing hook \"${hook}\""
		fi

		case "${hook}" in
		# client-side
		pre-commit | post-checkout | post-commit | post-rewrite | post-merge)
			# one of our current hooks
			case "${hook_version}" in
			stamper-"${STAMPER_VERSION_TEXT}")
				# our hook, version OK
				if [[ "true" == ${STAMPER_HOOKS[${hook}]} ]]; then
					if [[ "true" == ${STAMPER_SETUP_HOOKS} ]]; then
						__update_this_hook__ "setup" "${hook}" "${hook_path}" "force setup \"${hook}\" ${STAMPER_VERSION_TEXT}"
					else
						__VERBOSE__ ".   version OK \"${hook}\""
					fi
				else
					if [[ "true" == ${STAMPER_SETUP_HOOKS} ]]; then
						__update_this_hook__ "remove" "${hook}" "${hook_path}" "unused \"${hook}\" ${STAMPER_VERSION_TEXT}"
					else
						echo -e "Warning: do not remove version-stamper hook \"${hook}\" without --setup option" >&2
					fi
				fi
				;;
			stamper-*)
				# our hook, version differs
				if [[ "true" == ${STAMPER_HOOKS[${hook}]} ]]; then
					__update_this_hook__ "setup" "${hook}" "${hook_path}" "change \"${hook}\" to ${STAMPER_VERSION_TEXT}"
				else
					__update_this_hook__ "remove" "${hook}" "${hook_path}" "unused \"${hook}\" ${hook_version}"
				fi
				;;
			missing)
				# missing file
				if [[ "true" == ${STAMPER_HOOKS[${hook}]} && "true" == ${STAMPER_SETUP_HOOKS} ]]; then
					__update_this_hook__ "setup" "${hook}" "${hook_path}" "setup \"${hook}\" ${STAMPER_VERSION_TEXT}"
				else
					__VERBOSE__ ".   skip missing \"${hook}\""
				fi
				;;
			*)
				# wrong or empty 'hook_version' -- hook is not our
				__VERBOSE__ "#   DO NOT change \"${hook}\""
				;;
			esac
			;;
		prepare-commit-msg | commit-msg | applypatch-msg | pre-applypatch | post-applypatch | pre-rebase | pre-push | pre-auto-gc)
			# "missing" cannot be here because we enumerate existing files; so empty string for foreign or version string for our older hook
			if [[ -n ${hook_version} ]]; then
				__update_this_hook__ "remove" "${hook}" "${hook_path}" "mismatch suite version"
			fi
			;;
		# server-side
		pre-receive | update | post-receive)
			# "missing" cannot be here because we enumerate existing files; so empty string for foreign or version string for our older hook
			if [[ -n ${hook_version} ]]; then
				__update_this_hook__ "remove" "${hook}" "${hook_path}" "mismatch suite version"
			else
				__VERBOSE__ "#   touch \"${hook_path}\"    server-side hook"
			fi
			;;
		# undocumented by 'pro git' book
		fsmonitor-watchman | post-update)
			if [[ -n ${hook_version} ]]; then
				__update_this_hook__ "remove" "${hook}" "${hook_path}" "mismatch suite version"
			else
				__VERBOSE__ "#   touch \"${hook_path}\"    undocumented by 'pro git' book"
			fi
			;;
		# unknown
		*)
			;;
		esac
	done
}

#
# check/update/setup git hooks
#
if [[ "false" != ${STAMPER_SETUP_HOOKS} ]]; then
	if [[ -n ${VERSION_CONFIG_PREFIX} ]]; then
		echo "Warning: do not update git hooks because \"${VERSION_CONFIG_DIR}\" differs from worktree root \"${VERSION_ROOT_DIR}\"" >&2
	else
		if [[ -z ${VERSION_HOOKS_DIR} ]]; then
			echo "Warning: cannot find '.git/hooks' folder to update git hooks" >&2
		else
			__VERBOSE__ "Update hooks now"
			
			if [[ -n ${STAMPER_HOOKS[${STAMPER_SCRIPT_NAME}]} ]]; then
				# for version stamper project itself executed plugin may change
				# current version data, so reload version file before updating hooks.
				__VERBOSE__ "Reload version information before check/create hooks"
				source "${STAMPER_SCRIPT_PATH}-this"
				unset STAMPER_HOOKS[${STAMPER_SCRIPT_NAME}]
			fi

			STAMPER_SCRIPT_CMD="$(which -- "${STAMPER_SCRIPT_NAME}" 2>/dev/null)"
			__VERBOSE__ "Check path to script:\n.   running=\"${STAMPER_SCRIPT_PATH}\"\n.   on PATH=\"${STAMPER_SCRIPT_CMD}\""
			if [[ ${STAMPER_SCRIPT_CMD} == ${STAMPER_SCRIPT_PATH} ]]; then
				# version-stamper is installed and is used from install location
				STAMPER_SCRIPT_CMD="${STAMPER_SCRIPT_NAME}"
			else
				__STDPATH_FUNCTION__ --var STAMPER_SCRIPT_CMD --base "${VERSION_ROOT_DIR}" --mixed -- "${STAMPER_SCRIPT_PATH}"
				# relative path is in form 'folder/file' so we must change it to './folder/file' to execute it
				[[ ${STAMPER_SCRIPT_CMD} =~ ^/ ]] || STAMPER_SCRIPT_CMD="./${STAMPER_SCRIPT_CMD}"
			fi
			__VERBOSE__ "Use path to script=\"$STAMPER_SCRIPT_CMD\""

			__update_all_hooks__
		fi
	fi
fi
EXIT 0
