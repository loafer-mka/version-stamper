
# Лицензия <a name="C1"/>

This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not distributed
with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  
> Данная форма исходного кода регулируется условиями Общественной
> Лицензии Mozilla версии 2.0. Если копия MPL не распространялась
> вместе с этим файлом, вы можете получить ее по адресу
> http://mozilla.org/MPL/2.0/.

```
        email: Andrey Makarov <mka-at-mailru@mail.ru>
 Project home: https://github.com/loafer-mka/version-stamper.git

               Copyright (c) Andrey Makarov 2023
```

# Содержание <a name="C2"/>

- [Лицензия](#C1)
- [Содержание](#C2)
- [Введение](#C3)
- [Установка и использование](#C4)
  - [Параметры version-stamper](#C4.1)
  - [Команды version-stamper](#C4.2)
  - [Файл конфигурации .version-stamper](#C4.3)
- [Улучшения version-stamper](#C5)
  - [Разработка собственных плагинов](#C5.1)
    - [`__PLUGIN_XXX_NOTICE__`](#C5.1.1)
    - [`__PLUGIN_XXX_SAMPLE__`](#C5.1.2)
    - [`__PLUGIN_XXX_ATTRIB__`](#C5.1.3)
    - [`__PLUGIN_XXX_GETVER__`](#C5.1.4)
    - [`__PLUGIN_XXX_CREATE__`](#C5.1.5)
    - [`__PLUGIN_XXX_MODIFY__`](#C5.1.6)
  - [Разработка собственных средств форматирования текста версии](#C5.2)
  - [Тестирование](#C5.3)
- [Приложения](#C6)
  - [Общие проблемы в Windows](#C6.1)
    - [Разные корни файловых систем](#C6.1.1)
    - [Отсутствие символьных ссылок](#C6.1.2)
    - [Режим доступа к файлам и папкам](#C6.1.3)
  - [Немного о перехватчиках git (git hooks)](#C6.2)
  - [Обзор структуры каталогов репозитория git](#C6.3)

# Введение <a name="C3"/>

Version-stamper является несложным скриптом для генерации текстовых
файлов на разных языках программирования, содержащих информацию о текущей
версии проекта - условно называемый "штамп версии".

Информация о версии основывается на команде `git describe`, ограниченной
применением тэгов только вида `vMJ.MN`, где `MJ` и `MN` - целочисленные
старший и младший номера версии, а буква `v` может быть заменена любой
иной буквой, расстоянии между текущим коммитом и использованным тэгом, а
также иных сведениях - дате, авторе, хосте и т.п.

Поддержка разных языков программирования реализуется вспомогательными
"плагинами", список которых можно расширять. На данный момент поддерживаются:

- язык C/C++ (значения представлены набором макросов)
```
	#ifndef __VERSION_GUARD_H__
	#       define  __VERSION_GUARD_H__
	#       define  VERSION_ID          	0x0102014DL
	#       define  VERSION_TEXT        	"v1.2.333-branchname"
	#       define  VERSION_DATE        	"2023-11-06 20:16:40"
	#       define  VERSION_SHORTDATE   	"231106201640"
	#       define  VERSION_UNIXTIME    	1699291000LL
	#       define  VERSION_BRANCH      	"branchname"
	#       define  VERSION_HOSTINFO    	"your@email.org openSUSE Leap 15.5"
	#       define  VERSION_AUTHORSHIP  	"Your Name"
	#       define  VERSION_DECLARATION 	"Copyright (c) Your Name 2023"
	#		define  VERSION_COMMIT_AUTHOR	"Your Name <your@email.org>"
	// information below based on parent commit's hash
	#       define  VERSION_SHA_SHORT   	"p:e2477886"
	#       define  VERSION_SHA_LONG    	"p:e2477886f1fff6ddac0e533f22d7be244674e064"
	#endif
```

- язык C# (изменения записываются в традиционный Properties/AssemblyInfo.cs)
```
	using System.Reflection;
	using System.Runtime.CompilerServices;
	using System.Runtime.InteropServices;

	// General Information about an assembly is controlled through the following
	// set of attributes. Change these attribute values to modify the information
	// associated with an assembly.
	[assembly: AssemblyTitle("")]

	...

	[assembly: AssemblyVersion("1.2.333.*")]
	[assembly: AssemblyFileVersion("1.2.333.32")]
	// if used hash below is based on parent commit's then prefix 'p:' will be used
	[assembly: AssemblyInformationalVersion( "v1.2.333-branchname 2023-11-06 20:16:40 your@email.org openSUSE Leap 15.5 p:e2477886" )]
```

- Makefile скрипт (определяется набор переменных)
```
	VERSION_ID := 0102014D
	VERSION_TEXT := v1.2.333-branchname
	VERSION_DATE := 2023-11-06 20:16:40
	VERSION_SHORTDATE := 231106201640
	VERSION_UNIXTIME := 1699291000
	VERSION_BRANCH := branchname
	VERSION_HOSTINFO := your@email.org openSUSE Leap 15.5
	VERSION_AUTHORSHIP := Your Name
	VERSION_DECLARATION := Copyright (c) Your Name 2023
	VERSION_COMMIT_AUTHOR := Your Name <your@email.org>
	# if information below is based on parent commit's hash then prefix 'p:' will be used
	VERSION_SHA_SHORT := p:e2477886
	VERSION_SHA_LONG := p:e2477886f1fff6ddac0e533f22d7be244674e064
```

- Cmake скрипт (определяется набор переменных)
```
	if( NOT DEFINED __VERSION_GUARD_CMAKE__ )
        set( __VERSION_GUARD_CMAKE__ 1 )
        set( VERSION_ID            "0102014D" )
        set( VERSION_TEXT          "v1.2.333-branchname" )
        set( VERSION_DATE          "2023-11-06 20:16:40" )
        set( VERSION_SHORTDATE     "231106201640" )
        set( VERSION_UNIXTIME      "1699291000" )
        set( VERSION_BRANCH        "branchname" )
        set( VERSION_HOSTINFO      "your@email.org openSUSE Leap 15.5" )
        set( VERSION_AUTHORSHIP    "Your Name" )
        set( VERSION_DECLARATION   "Copyright (c) Your Name 2023" )
        set( VERSION_COMMIT_AUTHOR "Your Name <your@email.org>" )
	#   if information below is based on parent commit's hash then prefix 'p:' will be used
        set( VERSION_SHA_SHORT     "p:e2477886" )
        set( VERSION_SHA_LONG      "p:e2477886f1fff6ddac0e533f22d7be244674e064" )
	endif()
```

- Matlab скрипт (определяется класс с константными полями)
```
	classdef sample_Matlab
		properties (Constant)
			VERSION_ID = hex2dec('0102014D');
			VERSION_HEX = '0x0102014D';
			VERSION_TEXT = 'v1.2.333-branchname';
			VERSION_BRANCH = 'branchname';
			VERSION_DATE = '2023-11-06 20:16:40';
			VERSION_SHORTDATE = '231106201640';
			VERSION_UNIXTIME = 1699291000;
			VERSION_HOSTINFO = 'your@email.org openSUSE Leap 15.5';
			VERSION_AUTHORSHIP = 'Your Name';
			VERSION_DECLARATION = 'Copyright (c) Your Name 2023';
			VERSION_COMMIT_AUTHOR = 'Your Name <your@email.org>';
			% if information below is based on parent commit's hash then prefix 'p:' will be used
			VERSION_SHA_SHORT = 'p:e2477886';
			VERSION_SHA_LONG = 'p:e2477886f1fff6ddac0e533f22d7be244674e064';
		end
	end
```

- Bash или Sh скрипт (определяется набор переменных)
```
	#!/bin/bash

	VERSION_ID=0x0102014D
	VERSION_TEXT="v1.2.333-branchname"
	VERSION_DATE="2023-11-06 20:16:40"
	VERSION_SHORTDATE="231106201640"
	VERSION_UNIXTIME="1699291000"
	VERSION_BRANCH="branchname"
	VERSION_HOSTINFO="your@email.org openSUSE Leap 15.5"
	VERSION_AUTHORSHIP="Your Name"
	VERSION_DECLARATION="Copyright (c) Your Name 2023"
	VERSION_COMMIT_AUTHOR="Your Name <your@email.org>"
	# if information below is based on parent commit's hash then prefix 'p:' will be used
	VERSION_SHA_SHORT="p:e2477886"
	VERSION_SHA_LONG="p:e2477886f1fff6ddac0e533f22d7be244674e064"
```

- Windows cmd скрипт (.bat, определяется набор переменных окружения)
```
	@echo off

	set VERSION_ID=0x0102014D
	set VERSION_TEXT=v1.2.333-branchname
	set VERSION_DATE=2023-11-06 20:16:40
	set VERSION_SHORTDATE=231106201640
	set VERSION_UNIXTIME=1699291000
	set VERSION_BRANCH=branchname
	set VERSION_HOSTINFO=your@email.org openSUSE Leap 15.5
	set VERSION_AUTHORSHIP=Your Name
	set VERSION_DECLARATION=Copyright (c) Your Name 2023
	for /F "tokens=*" %%a in ("Your Name <your@email.org>") do set VERSION_COMMIT_AUTHOR=%%a
	rem if information below is based on parent commit's hash then prefix 'p:' will be used
	set VERSION_SHA_SHORT=p:e2477886
	set VERSION_SHA_LONG=p:e2477886f1fff6ddac0e533f22d7be244674e064
```

- короткая строка информации о версии в текстовом файле (плагин INFO);
  может быть удобна для средств автоматического сбора сведений о версиях
  разных компонент
```
	v1.2.333-branchname  2023-11-06 20:16:40  clean  p:e2477886  Your Name <your@email.org>  "(previous commit) Short commit message"
```

- Markdown текст с представлением сведений о версии в виде таблички,
  сопровождаемой логом репозитория с несколькими последними коммитами
  (до 10 записей)
```
	### Version data:

	| Version | v1.2.333-branchname |
	|--------:|:----------------|
	| Version ID | 0x0102014D |
	| Branch | branchname |
	| Date | 2023-11-06 20:16:40 |
	| Worktree | clean |
	| Commiter | Your Name &lt;your@email.org&gt; |
	| Commit SHA | p:e2477886f1fff6ddac0e533f22d7be244674e064 |
	| Build Host | your@email.org openSUSE Leap 15.5 |
	| Unix Time | 1699291000 |
	| Folder | `/data/home/your/prjects/test_work` |
	| | Copyright (c) Your Name 2023 |

	### Last log records:

	` ` `
	* e247788 (HEAD -> master) Short commit message
	* 46717a2 fix: some changes
	* 3efaaf8 (origin/master, origin/HEAD) Useless commit
	* 0bdbef2 Too old commit
	* a30cfe0 what do I do?
	...
	` ` `
```

Для поддержки другого языка или альтернативного представления штампа
версии надо изменить или добавить соответствующий плагин.

Если в одном проекте используется множество подпроектов в отдельных
репозиториях, то может получиться так, что несколько разных "штампов"
от разных подпроектов должны использоваться одновременно. Чтобы избежать
путаницы с совпадающими идентификаторам (например, `VERSION_TEXT`) разных
штампов, эти идентификаторы можно модифицировать, дописав к ним специфичные
префиксы и/или суффиксы, например, `YOURPROJECT_VERSION_TEXT` или
`VERSION_TEXT_YOURPROJECT`. Это и некоторые другие вещи, достигаются
путём редактирования конфигурационного файла .version-stamp в корне
рабочего дерева проекта.

# Установка и использование <a name="C4"/>

Для использования version-stamper'а достаточно обеспечить возможность
выполнения основного скрипта version-stamper из каталогов вашего проекта.
Version-stamper может быть как размещён в каком-либо каталоге на пути
поиска исполняемых файлов (`PATH`), так и просто скопирован в какой-либо
каталог, в том числе включён в ваш проект в виде подмодуля или копии,
чтобы его выполнять по явно задаваемому абсолютному или относительному
пути до скрипта version-stamper.

Применение:

```
   version-stamper [options] [commands]
```

Параметры version-stamper'а можно условно разделить на две группы

- только приводящие к отображению сведений (например, `--help`)

- создающие файлы со штампами версий или конфигурации

Первая группа параметров не имеет побочных эффектов, а вторая - приводит
к формированию "рабочего окружения" для version-stamper'а, включая
создание (если нет) файла конфигурации с параметрами по умолчанию,
установке перехватчиков (git hook), изменению или созданию `.gitignore`
и `.gitattributes`.

При удалении version-stamper надо убедиться, что удалён его конфигурационный
файл (`.version-stamper` в корне проекта) и что удалены перехватчики
(т.н. git hooks). см. каталог `.git/hooks/`, принадлежащие version-stamper.
Все перехватчики, принадлежащие version-stamper, содержат строку

```
export STAMPER_SUITE="Version suite v0.0-0.master"
```

где вместо v0.0-0.master указана конкретная версия и ветвь version-stamper'а.

## Параметры version-stamper <a name="C4.1"/>

Параметры обычно имеют так называемую короткую форму (например -V или -q)
и длинную форму (например, --version или --quiet). Параметры могут
применяться отдельно, а могут нуждаться в дополнительных значениях.
Так, параметры -cd, --directory и --git-hook нуждаются в значении, которое
можно задать либо дополнительным аргументом через пробел:

```
your_project> ./tools/stamper/version-stamper --directory "/other/working/directory"
```

или с помощью присваивания:

```
your_project> ./tools/stamper/version-stamper --directory="/other/working/directory"
```

Допустимые параметры:

- `-V` или `--version`<br/>
  Вывести версию собственно version-stamper'а и завершить работу

- `-h` или `/?` или `--help` или `/help`<br/>
  Вывести данный текст и завершить работу.

- `-v` или `--verbose`<br/>
  Выводить отладочную информацию в процессе выполнения version-stamper'а.
  Информация выводится на `stderr`. Если `-v` используется дважды, то в
  вывод включаются отметки времени вида `[S.0MS (+DMS ms)]`, где `S.0MS`
  обозначает секунду и миллисекунды со старта `./version-stamper`, а
  `DMS` обозначает число миллисекунд с момента предыдущей отметки времени.

- `-q` или `--quiet`<br/>
  Отключить "говорливый" режим, включенный параметром `--verbose`.
  Предназначена для тех случаев, когда говорливый режим включен по умолчанию
  посредством файла конфигурации `.version-stamper`

- `-cd PATH` или `--directory PATH`
  Указать каталог, в котором надо выполнять version-stamper. Этот может
  быть любой подкаталог проекта, утилита будет определять корень рабочего
  дерева проекта (git worktree), к которому принадлежит указанная папка
  (или текущая, если `--directory` не использовался).
  Примечание: version-stamper также пытается определить факт того, что
  используемая папка принадлежит не просто проекту, а одному из его
  подмодулей.

- `-l` или `--list`<br/>
  Перечислить располагаемые плагины и вывести их конфигурацию - генерируемые
  файлы со штампами версий и включение этих файлов в `.gitignore` и
  `.gitattributes`.

```
  your_project> ./tools/stamper/version-stamper -l
  Folders:
     VERSION_CURRENT_DIR= /home/your_name/your_project
     VERSION_GIT_DIR=     /home/your_name/your_project/.git
     VERSION_ROOT_DIR=    /home/your_name/your_project
     VERSION_SUPER_DIR=   

     Plugin   = Target file                        Information
  -----------------------------------------------------------------------
     CS       = Properties/sample-AssemblyInfo.cs  config, fs: len=1571 2023-11-06 20:29:21
     BAT      = -                                  Not configured
     C        = -                                  Not configured
     CMAKE    = -                                  Not configured
     INFO     = -                                  Not configured
     M        = -                                  Not configured
     SH       = version.sh                         config, git: 2023-11-06 20:16:40 @9e4ee3e, fs: len=868 2023-11-06 20:29:22
     MAKEFILE = -                                  Not configured
     MARKDOWN = -                                  Not configured
```

  Информация о плагинах содержит признак, как плагин был запущен (аргументом
  командной строки или параметром конфигурации), сведения об этом файле
  в файловой системе (размер и дата) и сведениями об этом файле в репозитории
  git - дата и хэш коммита. Часть сведений может отсутствовать.

  `VERSION_CURRENT_DIR` - текущий каталог, в котором выполняется version-stamper.
  `VERSION_ROOT_DIR` - корневой каталог рабочего дерева проекта (git worktree),
  `VERSION_GIT_DIR` - папка `.git` репозитория, и `VERSION_SUPER_DIR` - 
  пустая строка в обычных случаях или путь к корню рабочего дерева
  суперпроекта, если данный проект включён в роли подмодуля.

- `-p` или `--print`<br/>
  Вывести вычисленные сведения о текущей версии.

```
  your_project> ./tools/stamper/version-stamper -p
  v1.2.333-branchname  2023-11-06 22:17:09  your@email.org openSUSE Leap 15.5
     VERSION_ID=            0102014D
     VERSION_TEXT=          v1.2.333-branchname
     VERSION_PREFIX=        v
     VERSION_MAJOR=         1
     VERSION_MINOR=         2
     VERSION_SUFFIX=
     VERSION_BUILD=         333
     VERSION_BRANCH=        branchname
     VERSION_DIRTY=       
     VERSION_DATE=          2023-11-06 22:17:09
     VERSION_SHORTDATE=     231106221709
     VERSION_UNIXTIME       1699298229
     VERSION_SHA_LONG=      47920119e1110edeeda572e5612ab211096fdc6a
     VERSION_SHA_SHORT=     47920119
     VERSION_HOSTINFO=      your@email.org openSUSE Leap 15.5
     VERSION_AUTHORSHIP=    Your Name
     VERSION_DECLARATION=   Copyright (c) Your Name 2023
     VERSION_COMMIT_AUTHOR= Your Name
     VERSION_COMMIT_EMAIL=  your@email.org
     VERSION_SUBMOD_NAME= 
     VERSION_SUBMOD_PATH= 
     VERSION_LEADER=      
     VERSION_TRAILER=     
     Note. The identifier names listed here are exposed in the plugin, not in the target file.
```

  Здесь версия `v1.2` - ближайший тэг, содержащий старший и младший номера
  версий, 333 - номер сборки (расстояние от текущего коммита до тэга),
  эти сведения возвращает

```
     git --no-pager describe --long --tags --match="[A-Za-z][0-9]*.[0-9]*" HEAD
```

  Код версии `VERSION_ID`, в примере равный 0102014D, это 32-х битовое
  число, содержащее в старшем байте старший номер версии `VERSION_MAJOR`,
  в следующем байте - младший номер `VERSION_MINOR`, а в младшем 16-ти
  битовом слове - номер сборки `VERSION_BUILD`. Параметр `VERSION_PREFIX`
  это первая буква (в большинстве случаев `v'), а `VERSION_SUFFIX` — это
  обычно пустая строка, кроме случаев использования сложного имени тега
  (например, если имя тега — `v1.22.333', то `VERSION_SUFFIX` = `.333').
  
  Имя текущей ветви `VERSION_BRANCH` - либо имя присоединённой ветви, либо
  вычисляемое, если HEAD отсоединён (что часто бывает для подмодулей).
  Вычисления не могут гарантировать правильность вычисления или выбора,
  если данному коммиту может соответствовать несколько подходящих ветвей,
  в этом случае к имени ветви дописывается символ `?`.

  `VERSION_DIRTY` - флаг изменённого рабочего дерева (не учитывая изменений
  в штампах версий). Обозначается символом `+` если есть несохранённые в
  репозитории изменения. В этом случае символ `+` также дописывается к
  имени ветви в `VERSION_TEXT`.

  `VERSION_DATE`, `VERSION_SHORTDATE` и `VERSION_UNIXTIME` - содержат
  текущую дату (может отличаться от даты коммита; особенно для изменённого
  рабочего дерева).

  `VERSION_SHA_LONG` и `VERSION_SHA_SHORT` - содержат информацию о текущем
  коммите и о его предках (в этом случае дописывается префикс `p:` перед
  хэшем). Хэш предка применяется в `pre-commit` перехватчике, т.к. хэш
  нового коммита в это время ещё не известен.

  `VERSION_AUTHORSHIP` и `VERSION_DECLARATION` - берутся из конфигурационного
  файла `.version-stamper`, при его создании первоначально присваиваются
  на основе имени пользователя, конфигурации git и начального значения
  параметра `STAMPER_DEFAULT_DECL` в файле `version-stamper-config`.
  
  `VERSION_COMMIT_AUTHOR` и `VERSION_COMMIT_EMAIL` - извлекаются из сведений
  о текущем коммите. Если репозиторий совсем пустой, то на основе имени
  пользователя и его e-mail в конфигурации git.

  `VERSION_LEADER` и `VERSION_TRAILER` - берутся из конфигурационного
  файла `.version-stamper`, при его создании первоначально остаются либо
  пустыми строками, а в случае подмодуля `VERSION_LEADER` формируется из
  имени подмодуля. Задают префиксы и суффиксы имён символов в штампах
  версии (определяют модификацию, к примеру, общего `VERSION_TEXT` в
  специфичный `YOURPROJECT_VERSION_TEXT`). Это может потребоваться для
  проектов, состоящих из нескольких частей, каждая из которых имеет своё
  обозначение версии, и в этом случае надо, чтобы используемые для этого
  имена переменных, объектов и/или макросов были уникальными.

  Команда `--print` всегда выводит обозначения без префикса и суффикса по
  двум соображениям: во-первых, это упрощает разбор в каких-либо скриптах
  и, во-вторых, префикс и суффикс к именам добавляются плагинами, в тексте
  плагина они используются без префиксов и суффиксов, а плагины считаются
  адаптируемыми под нужды проекта - их изменение и разработка собственных
  приветствуется.

  `VERSION_SUBMOD_NAME` и `VERSION_SUBMOD_PATH` соответствуют пустым
  строкам, если только штампы не создаются для подмодуля проекта. При этом
  также становится непустым параметр `VERSION_SUPER_DIR`.

  Примечание: параметры `VERSION_TEXT`, `VERSION_BRANCH`, `VERSION_DIRTY`,
  `VERSION_DATE`, `VERSION_HOSTINFO`, `VERSION_AUTHORSHIP`,
  `VERSION_DECLARATION`, `VERSION_SUBMOD_NAME`, `VERSION_SUBMOD_PATH`,
  `VERSION_COMMIT_AUTHOR` и `VERSION_COMMIT_EMAIL` могут содержать
  специальные символы, которые должны быть экранированы или продублированы
  в некоторых случаях (скажем, `\` или `"` в строковом литерале языка C).
  Поэтому у каждого из этих символов есть специальные 'близнецы',
  заканчивающиеся суффиксами `_QUOTED` или `_RQREG` (например:
  `VERSION_TEXT`, `VERSION_TEXT_QUOTED` и `VERSION_TEXT_RQREG`). Эти
  'близнецы' могут использоваться в скриптах при подстановке в строку,
  заключенную в двойные кавычки (`..._QUOTED`) или в правую часть
  расширенного регулярного выражения `sed`, заключенную в двойные кавычки
  (`..._RQREG`), т.е. в выражения вида
  `sed --regexp-extended -e "s/.../...${VERSION_TEXT_RQREG.../"`, см.
  исходные тексты плагинов в качестве примеров использования.

- `-c` или `--config`<br/>
  Создать конфигурационный файл .version-stamper, если он отсутствует и
  установить стандартный набор перехватчиков git. Список устанавливаемых
  перехватчиков указан в конфигурационном файле .version-stamper, если его
  изменить, то надо будет выполнить команду `-s` или `--setup` для изменения
  набора указанных перехватчиков. Обновление установленных перехватчиков
  до актуальной версии выполняется не только командой `-s` или `--setup`,
  но также и командой `-g` (`--generate`).

- `-s` или `--setup`<br/>
  Установить перехватчики, указанные в конфигурационном файле. Данная
  команда используется для принудительного обновления перехватчиков.

- `-g` или `--generate`<br/>
  Выполнить все плагины, сконфигурированные в .version-stamper. Эта
  команда также приводит к обновлению перехватчиков, если версии различаются,
  но ни установки новых перехватчиков, ни удаления существующих бех опции
  `-s` или `--setup` не выполняется.

- `--git-hook GITHOOK`<br/>
  Используйте эту опцию, когда version-stamper запускается из git-хука.
  Он передает имя ловушки (без пути и с ведущими '/' и/или '.'). Эта опция
  включает специальную обработку во время выполнения ловушки.
  Примечание: не указывайте его вручную (кроме только теста), его необходимо
  использовать в коде соответствующих перехватчиков git.

Предполагается, что обычно `version-stamper` используется в репозиториях,
имеющих конфигурационный файл `.version-stamper` в корне рабочего дерева.
Однако в некоторых случаях `version-stamper` может быть использован в любых
репозиториях, в том числе не имеющих нужного конфигурационного файла. Так,
например, может быть если `version-stamper` использован для создания отчётов
в составных проектах с несколькими репозиториями. Перечисленные ниже опции
позволяют задать основные параметры, в нормальной ситуации получаемые из
конфигурационного файла.

*Примечание:* не используйте опции `--generate`, `--config` или `--setup`
в таких случаях, так как они приведут к созданию конфигурационного файла
и установке перехватчиков, тогда как без этих опций можно создать нужные
файлы со штампами версий или отчётами без каких-либо изменений в рабочем
дереве проекта.

- `--leader TEXT` или `--leader? TEXT`<br/>
- `--trailer TEXT` или `--trailer? TEXT`<br/>
  Задают префикс и/или суффикс имён символов, т.е. значения `VERSION_LEADER`
  и `VERSION_TRAILER` (см. выше). По умолчанию значения пустые строки, но
  для подмодулей предполагаемое значение `--leader` по умолчанию формируется
  на основе имени подмодуля. Варианты опций, имена которых заканчиваются
  на вопросительный знак, задают соответствующие параметры только если
  они не были ранее заданы в конфигурационном файле `.version-stamper`.

- `--authorship TEXT` или `--authorship? TEXT`<br>
- `--declaration TEXT` или `--declaration? TEXT`<br>
  Задают текст копирайта или копилефта (т.е. параметр `declaration` файла
  конфигурации) и обозначение авторства (т.е. параметр `authorship`).
  Подробнее см. в описании файла конфигурации ниже.  Варианты опций, имена
  которых заканчиваются на вопросительный знак, задают соответствующие
  параметры только если они не были ранее заданы в конфигурационном файле
  `.version-stamper`.

- `--textoize VARIANT` или `--textoize? VARIANT`<br/>
  Выбирают формат представления номера версии, возможны три разных значения
  `none`, `default` и `alt`. Подробнее см. описание параметра `textoize`
  конфигурационного файла `.version-stamper`.

## Команды version-stamper <a name="C4.2"/>

Наряду с перечисленными выше параметрами командная строка может содержать
команды запуска плагинов. Если штамп, создаваемый указанным в командной
строке плагином, также создаётся плагином, настроенным в конфигурационном
файле, то свойства этого штампа определяются конфигурацией, а не командной
строкой.

Команда для выполнения плагина имеет вид:

```
your_project> ./tools/stamper/version-stamper ... PLUGIN [plugin_options] FILE
```

В командной строке может быть подряд указано несколько команд для создания
штампов версий, допустимо создание нескольких штампов одного типа с разными
именами файлов (правда, их содержимое может не отличаться, так что 
целесообразность сомнительна)

Допустимых параметров плагина `plugin_options` только два, и они
взаимоисключающие:

- `-i` или `--gitignore`<br/>
  При создании штампа включить его также в `.gitignore`

- `-a` или `--gitattributes`<br/>
  Добавить параметры штампа (обычно тип используемого завершения
  строки - eol=lf или eol=crlf) в файл `.gitattributes`.

- `--leader TEXT`<br/>
- `--trailer TEXT`<br/>
  Задают специфичный для данного штампа префикс и/или суффикс имён символов,
  т.е. переопределяют общие значения `VERSION_LEADER` и `VERSION_TRAILER`
  (см. выше) для конкретного штампа версии.

Поддерживаемые на данный момент плагины и используемый символ
завершения строки:

- `BAT` Windows Batch file; завешение строки CR+LF.

- `C` C-style defines; завершение строки - нативное, LF в Linux/Unix и
  CR+LF в Windows.

- `CMAKE` CMake script; завершение строки LF.

- `CS` C# assembly properties, обычно он создаётся Visual Studio, а не
  плагином; завершение строки CR+LF.

- `INFO` однострочный текстовый файл, завершение строки нативное.

- `M` Matlab's class definition; завершение строки CR+LF.

- `MAKEILE` Makefile script; завершение строки LF.

- `MARKDOWN` текстовый файл с разметкой markdown, завершение строки нативное.

- `SH` Shell script; завершение строки CR+LF.

Эта команда создаёт или обновляет файл с актуальной информацией о версии.
Если такой файл не существует, то создаётся новый файл; в противном случае
файл считывается и в нём выборочно изменяются сведения о версии. Это
позволяет дополнять такие файлы любой дополнительной информацией, которая
будет сохраняться от обновления к обновлению.

Вместо имени файла допустимо указать `-`, тогда штамп версии будет создан
и выведен на стандартный вывод или `--`, тогда штамп версии будет считываться
со стандартного ввода, корректироваться и затем выводиться на стандартный
вывод.

Пример:

```
your_project> ./tools/stamper/version-stamper ... MAKEFILE -i build/version.mk
```

Автоматического обновления созданных "руками" штампов не выполняется, если
вы их используете, то предусмотрите выполнение необходимых команд в своих
скриптах сборки проекта.

Удобнее настроить генерацию нужных штампов в .version-stamper и обновлять
из либо одной командой `version-stamper --generate`, либо автоматически
перехватчиками git при создании или изменении коммитов.

Если ни параметры `-g`, `--generate`, `-c`, `--config`, ни команды
выполнения плагинов не указаны, то version-stamper будет подставлять
вместо команд параметр конфигурации `default-cmd`, а если и он не задан
или пуст, тогда будет использоваться `--help`.

## Файл конфигурации .version-stamper <a name="C4.3"/>

Файл конфигурации .version-stamper размещается в корне рабочего дерева
проекта и содержит:

- строки-комментарии, начинающиеся с символа `#`, эти строки пропускаются

- назначения параметров в виде:

```
 параметр: значение
```

  После двоеточия должен быть, как минимум, один пробельный символ, за
  которым с первого непробельного начинается значение параметра и
  продолжается до конца строки. Если таким именем является имя файла и
  оно содержит пробелы, то брать его в кавычки и как-либо экранировать
  не надо.

Допустимые параметры:

1. `verbose` - режим говорливости. Допустимые значения: `0`, `notset`,
   `false`, `quiet`, `none`, `clean`, `off`, `no`, `f`, `n` отключают
   отладочный вывод (эквивалент аргументу `--quiet` или `-q` командной
   строки); значения `1`, `verbose`, `simple`, `true`, `yes`, `set`, `ok`,
   `on`, `t`, `y` включают простой говорливый режим (соответствуют одному
   аргументу `--verbose` или `-v` в командной строке), а значения `2`,
   `extended` дополнительно включают отметки времени в отладочный вывод
   (соответствует двум аргументам `--verbose` или `-v` в командной строке).
   Если ничего не указано, то по умолчанию предполагается `quiet`.

2. `abbrev` - число символов в короткой форме хэша, по умолчанию 8 символов.

3. `leader` и `trailer` используются для присвоения префиксов имён символов
  `VERSION_LEADER` и `VERSION_TRAILER`. Обычно значения либо пустые строки,
  либо параметры закомментированы, но для подмодулей предполагаемое значение
  `leader` формируется на основе имени подмодуля.

4. `authorship` используется для присвоения `VERSION_AUTHORSHIP` и
  формирования строки копирайта или копилефта (см. параметр `declaration`).
  Обычно не нужны, но некоторые штампы (например, для C#) содержат информацию
  о копирайте. 

5. `declaration` - строка копирайта или копилефта. Может быть изменена
  произвольным образом ... но не забывайте о том, чтобы она соответствовала
  принятой в вашем проекте лицензии. По умолчанию в создаваемом файле
  конфигурации она формируется из параметра `STAMPER_DEFAULT_DECL`
  (см. файл `version-stamper-config` из состава version-stamper), задающего
  текст начала строки (т.е. "Copyright (c)" или "Copyleft" и т.п.),
  авторства (как в параметре `authorship`) и года первого коммита в проекте
  или текущего года, если проект ещё пустой.

6. `default-cmd` - команда, подставляемая по умолчанию, если в командной
   строке version-stamper нет никаких существенных команд и параметров.
   Обычное значение либо `--help` (подходит для только что начатых проектов),
   либо `--list` и/или `--print`, что может быть удобно, когда к команде
   version-stamper уже привыкли и важнее получать сведения о текущей версии
   и/или конфигурации.

7. `textoize` определяет вариант формирования текстового представления
   версии. Возможны три значения для этого параметра:
   - `none` (или вообще не назначать) - обычное представление в виде
     "v1.2.333-branch", где числа представляют старший и младший номера
     версий и номер "сборки" - расстояние в коммитах до тэга версии.
   - `default` - формат версии такой же, но имя ветки `branch` в некоторых
     случаях сокращается - вместо некоторых типичных префиксов `feature-`,
     `hotfix-`, `fix-`, `issue-`, `release-` используются укороченные
     варианты `f:`, `x:`, `x:`, `#`, и `R:`.
   - `alt` тоже транслирует имена веток, но немного отличается формат
     строки: "v1.2-333.branch" (форма номеров как у `git describe`).

8. Список генерируемых по умолчанию штампов. Отличается от команд командной
  строки version-stamper, приводящих к выполнению плагинов, только наличием
  префикса `plugin-` перед именем плагина.<br/>
  <br/>
  `plugin-PLUGIN [-i | --gitignore | -a | --gitattributes ] FILE`<br/>
  <br/>
  Это сделано, чтобы исключить
  случайное совпадение имени какого-либо плагина с каким-нибудь параметром
  конфигурации (в командной строке все прочие параметры начинаются с `-`
  или `--` и, таким образом, синтаксически выделены, шанс ошибки и так
  мал, а в конфигурации параметры не имеют чётко выделяющего их признака).
  <br/>
  <br/>
  О поддерживаемых плагинах см. в разделах о командах version-stamper 
  и в общем обзоре. Как и в случае командной строки, допустимо указание
  нескольких штампов, соответствующих одному плагину, на отдельных строках.

9. `hooks` перечисляет активируемые перехватчики git (git hooks). Возможно
  задание в виде пустой строки, говорящей о том, что никаких перехватчиков
  устанавливать не надо. Устанавливаемые перехватчики обеспечивают
  автоматическое выполнение version-stamper в тех случаях, когда git вносит
  изменения в репозиторий и обновляются текущие сведения - хэши коммитов,
  дата и время, номер сборки и пр.

Если приняты меры, чтобы `version-stamper --generate` выполнялся каждый
раз в процессе сборки, то постоянное поддержание штампов в более-менее
актуальном состоянии не требуется, но всё равно может быть рекомендовано.

Если устанавливать перехватчики не требуется, то оставьте `hooks` пустой
строкой (закомментированная соответствует стандартному набору). Изменять
предлагаемый набор имеет смысл в тех случаях, когда проект требует установки
своих собственных перехватчиков и они начинают конфликтовать с
перехватчиками version-stamper'а. Сокращение набора перехватчиков просто
уменьшит число случаев, в которых штампы будут автоматически перестраиваться.

Одновременное указание `pre-commit` и `post-commit` избыточно, но не критично.

Перехватчики обновляются при обновлении версии самого version-stamper'а
и при изменении пути, по которому его надо выполнять. Вызов version-stamper'а
из перехватчика выполняется тем способом, который был использован при выполнении
команды version-stamper, приводящей к обновлению перехватчиков. Если при этом
version-stamper был запущен по явно указанному пути, то такой же путь будет
применён и в перехватчике. Это упрощает включение version-stamper в ваш
проект - вы просто размещаете его где-то в дереве вашего проекта и вызываете
по относительному пути, после чего он адаптирует перехватчики так, чтобы
запускать version-stamper из указанного места.

Некоторые свойства перехватчиков:

- `pre-commit`

  удобно: штампы версий (если они отслеживаются, а не включены в `.gitignore`)
  могут быть изменены непосредственно перед коммитом и затем включены
  в него без специальных действий.

  неудачно: SHA содержит сведения о коммите-предке, а не о текущем коммите.
  Особые сложности представляют коммиты, заменяющие собой существующие
  (`--amend`), при которых текущий коммит удаляется, а вместо него создаётся
  новый (на момент срабатывания перехватчика неизвестный) коммит,
  наследующий предков отменяемого, которых может быть не один, а несколько,
  если заменяемый коммит был слиянием.

  неудачно: тип коммита (amend, message-only, squash и пр.) трудно
  определить, доступная в pre-commit информация недостаточна для этого.
  Приходится применять трюки.

- `post-commit`

  удобно: SHA соответствует актуальному только что созданному коммиту.

  неудачно: штампы версий обновляются после создания коммита, и если они
  отслеживаются репозиторием, до рабочее дерево становится изменённым (что
  выглядит странным, когда после коммита всё равно есть изменения и
  избавиться от этого не получается). Вносить штампы версий под контроль
  репозитория не рекомендуется вообще, а по причине сложностей в некоторых
  перехватчиках git особенно, но не всегда возможно - тот же штамп для
  C# входит в проект. Если существует возможность НЕ ВКЛЮЧАТЬ штамп в
  репозиторий, то используйте опцию `--gitignore` или `-i` для генерации
  штампа.

  неудачно: данный перехватчик может быть многократно вызван в процессе
  т.н. squash коммитов.

  удобно: переменная окружения GIT_REFLOG_ACTION помогает различать простые
  коммиты от особых случаев (rebase, merge и пр.).

- `post-checkout`

  удобно: SHA содержит актуальное значение.

  неудачно: переключение ветки или переход в "отсоединённый" режим
  (detached head) изменяет текущую ветвь и требует обязательной перегенерации
  штампов. Этот перехватчик желательно не отключать.

  неудачно: однако это же может приводить к краху squash операций, если
  файлы штампов оказываются под контролем репозитория (нарушаются
  последовательные объединения коммитов).

  удобно: переменная окружения GIT_REFLOG_ACTION помогает различать простые
  переключения (checkout) от особых случаев (rebase, merge и пр.).

- `post-rewrite`

  неудачно: может выполняться многократно в течении одной squash операции

  удобно: зато есть аргументы 'amend' или 'rebase', уточняющие что происходит

  неудачно: штампы версий обновляются после создания коммита, и если они
  отслеживаются репозиторием, то рабочее дерево становится изменённым (что
  выглядит странным, когда после коммита всё равно есть изменения и
  избавиться от этого не получается). 

  удобно: SHA содержит актуальное значение.

- `post-merge`

  неудачно: штампы версий обновляются после создания коммита, и если они
  отслеживаются репозиторием, то рабочее дерево становится изменённым (что
  выглядит странным, когда после коммита всё равно есть изменения и
  избавиться от этого не получается). 

# Улучшения version-stamper <a name="C5"/>

## Разработка собственных плагинов <a name="C5.1"/>

Для создания собственного плагина достаточно создать файл с именем,
соответствующим `version-stamper-plugin-XXX`, где вместо `XXX` подставлено
имя плагина и разместить этот файл рядом с `version-stamper`. Плагин
должен содержать несколько функций; в именах функций вместо `XXX` также
должно быть указано имя плагина. Например, функция, описанная здесь как
`__PLUGIN_XXX_NOTICE__` в случае плагина для языка скриптов `sh` должна
называться `__PLUGIN_SH_NOTICE__`.

Во время работы `version-stamper` вычисляет многие переменные (см. пример
выполнения команды `version-stamper --print` выше), имена таких переменных
начинаются на `VERSION_` и для обращения к нужным значениям необходимо
использовать именно такие имена. Но в тексте создаваемого целевого файла
имена назначаемых переменных могут быть любыми и совершенно не обязаны 
соответствовать именам внутренних переменных. В существующих плагинах в
большинстве случаев так и есть, но не всегда - для примера можно посмотреть
на плагин для С# (`version-stamper-plugin-CS`), в котором вообще нет почти
ничего общего, или на плагин для матлаба (`version-stamper-plugin-M`),
в котором есть похожая переменная `VERSION_ID`, но по основанию 10, а не
16, и шестнадцатеричная `VERSION_HEX`, но в виде строки. Аналогично, при
вычислении переменных существуют две разных `VERSION_COMMIT_AUTHOR` и
`VERSION_COMMIT_EMAIL`, а в файлах штампов `VERSION_COMMIT_AUTHOR`
является объединением имени и почтового адреса.

Ещё одна особенность заключается в том, что в большом проекте может
существовать несколько частей, каждая из которых создаёт свой штамп версии,
но позже при сборке они используются все вместе. Чтобы избежать путаницы
имён, предусмотрено дописывание к именам переменных префикса и/или суффикса
(в конфигурации `.version-stamper` они называются `leader` и `trailer`
соответственно). Соответственно, в плагинах для правильного формирования
имён переменных надо использовать конструкции вида (для примера пусть
будет переменная `VERSION_TEXT`):

```
${VERSION_LEADER}VERSION_TEXT${VERSION_TRAILER} = "${VERSION_TEXT}"
```

Чтобы не "городить огород" из плохо читаемых конструкций, для всех типичных
переменных заранее построены их составные имена и назначены переменным
`NAME_...`, например, для упомянутой переменной `VERSION_TEXT`, её имя
уже определено как `NAME_VERSION_TEXT` и в тексте плагина можно использовать
более понятную конструкцию:

```
${NAME_VERSION_TEXT} = "${VERSION_TEXT}"
```

Проще всего взять за основу любой существующий плагин и внести в него
необходимые изменения.

### `__PLUGIN_XXX_NOTICE__` <a name="C5.1.1"/>

Данная функция выводит на stdout короткое описание данного плагина. Это
описание используется командой `version-stamper --help` при формировании
списка поддерживаемых плагинов.

Например, функция может выглядеть так:

```
function __PLUGIN_BAT_NOTICE__
{
	echo "   plugin-BAT        Windows Batch file; eol=CR+LF"
}
```

### `__PLUGIN_XXX_SAMPLE__` <a name="C5.1.2"/>

Данная функция выводит на stdout однострочный пример использования плагина.
Этот пример включается в создаваемый командой `version-stamper --config`
файл конфигурации `.version-stamper`. В норме выводимая строка должна
начинаться с символа комментария `#`, так как создаваемый файл конфигурации
первоначально не содержит уже сконфигурированных плагинов - это должен
сделать автор проекта. Однако в частных случаях может быть иначе.

Пример:

```
function __PLUGIN_BAT_SAMPLE__
{
	echo "#plugin-BAT:      --gitignore  version.bat"
}
```

### `__PLUGIN_XXX_ATTRIB__` <a name="C5.1.3"/>

Данная функция выводит на stdout набор параметров, применяемый к создаваемому
штампу версии в `.gitattributes`. Обычные варианты:

- `text eol=lf` для файлов Unix/Linux с разделителем строк `LF`
- `text eol=crlf` для файлов Windows с разделителем строк `CR+LF`
- `text` для файлов, которые в разных системах могут иметь разные
  разделители, например, обычные `.c` или `.h` файлы.

Пример:

```
function __PLUGIN_BAT_ATTRIB__
{
	echo "text eol=crlf"
}
```

*Примечание:* Обновления файлов `.gitattributes` и `.gitignore` происходят
только при создании нового файла штампа версии.

### `__PLUGIN_XXX_GETVER__` <a name="C5.1.4"/>

Данная функция получает на stdin текст существующего штампа и должна вывести
на stdout текст с обозначением версии, соответствующий содержимому
`VERSION_TEXT` (т.е. строку вида "v1.2.333-branchname"). Этот текст
используется для сравнения имеющейся версии штампа с создаваемым. Если
текст обозначения версии совпадает и рабочий каталог "чистый", то файл
штампа не изменяется.

Обычно эту функцию можно реализовать с помощью простого sed или awk,
распознающего нужный шаблон и возвращающий результат.

*Примечание:* Существующий файл шаблона считывается до выполнения этой
функции и символы завершения строк приводятся к одиночным LF (Unix-style),
это позволяет использовать инструменты вида grep, awk, sed и т.п. не
заботясь о переводах строк.

В примере со штампами версий для `.bat` файлов - файл штампа содержит 
команды присвоения значений, в том числе, предположим, она содержит
команду вида `set VERSION_TEXT=v1.2.333-branchname`, а функция должна найти
и вернуть подстроку `v1.2.333-branchname`. Сделать это можно так:

```
function __PLUGIN_BAT_GETVER__
{
	sed --binary --regexp-extended --silent \
		-e "s/^(\s*set\s+${NAME_VERSION_TEXT}=\s*)(.*)$/\\2/p"
}
```

Функция ищет в тексте только "строгое" обозначение версии (т.е. строка 
должна содержать текст с ключевой последовательностью `VERSION_TEXT` с
префиксом и суффиксом (то есть `${NAME_VERSION_TEXT}`). Сделано это для
того, чтобы вернут пустую строку вместо версии, если изменены префикс или
суффикс имён переменных окружения: если возвращённая строка не совпадает с
ожидаемой версией, то штампы будут перестраиваться, пустая строка,
естественно, приведёт к несовпадению и замене файлов штампов.

### `__PLUGIN_XXX_CREATE__` <a name="C5.1.5"/>

Данная функция предназначена для создания нового файла штампа и вызывается,
когда целевого файла не существует. Функция получает аргумент, являющийся
именем создаваемого файла со штампом версии, в который должен быть записан
нужный текст. При записи штампа надо использовать правильные символы
завершения строк (LF или CR+LF), для чего удобно воспользоваться одной из
трёх доступных функций:

- `__STORE_LF__` - сохраняет файл с одиночными LF

- `__STORE_CRLF__` - сохраняет файл с CR+LF

- `__STORE_NATIVE_EOL__` - сохраняет файл с разделителями LF в unix-подобной
системе и CR+LF в Windows.

Текст сохраняемого файла подаётся на stdin, а аргумент функции содержит имя
сохраняемого файла. Типичный шаблон реализации такой функции:

```
function __PLUGIN_BAT_CREATE__
{
    __STORE_NATIVE_EOL__ "$1" <<-END_OF_TEXT
		@echo off

		set ${NAME_VERSION_TEXT}=${VERSION_TEXT}
		set ${NAME_VERSION_BRANCH}=${VERSION_BRANCH}${VERSION_DIRTY}
		rem ...
END_OF_TEXT
}
```

Следует иметь в виду, что "$1" может быть как именем реального файла, так
и некоторым специальным значением:

- `//-` используется для обозначения штампа, выводимого на стандартный
  вывод, при этом для создания штампа вызывается `__PLUGIN_XXX_CREATE__`.

- `//--` указывает, что штамп был получен со стандартного ввода, изменён,
  и на стандартный вывод отправляется штамп после изменений, для чего
  должна была быть вызвана функция `__PLUGIN_XXX_MODIFY__`.

В некоторых случаях надо не просто создать файл, но и назначить ему режим
доступа. Обычно для этого используется команда `chmod ...`, но в случае
`git-for-windows` она может не работать; более того, её эффект в разных
реализациях posix-совместимой среды в `windows` различен. Чтобы несколько
нивелировать эту разницу предусмотрена функция `__CHMOD__`.

### `__PLUGIN_XXX_MODIFY__` <a name="C5.1.6"/>

Данная функция используется в тех случаях, когда файл штампа уже существует
и в него надо внести изменения. Существующий штамп подаётся на stdin (с 
символами завершения строк LF), а единственным аргументом функции задаётся
имя файла штампа для записи. Как и `__PLUGIN_CS_CREATE__` функция должна
записать новый штамп с правильными символами завершения строк.

Рекомендуемая практика - находить в исходном штампе нужные подстроки и
заменять их, приводя в соответствие с новым штампом. Таким образом,
в типичном случае это может быть вызов sed или awk с набором шаблонов
для замены старых сведений о версии новыми.

Не рекомендуется пересоздавать файл заново - общая идея состоит в том,
что штамп может быть сокращён по сравнению с автоматически создаваемым
или, наоборот, дополнен чем-то новым. Именно поэтому рекомендуется просто
заменять найденные значения в существующем штампе, оставляя всё остальное
неизменным.

В частном случае из файла штампа авторами проекта может быть удалена
некоторая неиспользуемая часть информации о версии (например, хэши
коммита, которые когда соответствуют текущему коммиту, а когда его предкам).
На усмотрение разработчика плагина остаётся его поведение в этом случае -
отсутствующую информацию можно проигнорировать, а можно дополнить, чтобы
она всегда присутствовала в этом штампе.

Среди существующих плагинов большинство игнорируют отсутствие удалённых
сведений (обновляется только то, что было обнаружено), за исключением
единственного плагина для C#, который обеспечивает, чтобы параметр
`AssemblyInformationalVersion` присутствовал в штампе.

Пример:

```
function __PLUGIN_BAT_MODIFY__
{
	sed --binary --regexp-extended \
		-e "s/^(\s*set\s+)(\w*VERSION_TEXT\w*\s*)(=\s*)(.*)$/\\1${NAME_VERSION_TEXT}\\3${VERSION_TEXT}/" \
		-e "s/^(\s*set\s+)(\w*VERSION_BRANCH\w*\s*)(=\s*)(.*)$/\\1${NAME_VERSION_BRANCH}\\3${VERSION_BRANCH}${VERSION_DIRTY}/" \
	| __STORE_CRLF__ "$1"
}
```

В данном примере находятся строки, содержащие ключевые идентификаторы
(скажем, `\w*VERSION_TEXT\w*`, что соответствует подстроке `VERSION_TEXT`
с произвольными префиксом и суффиксом, состоящими из букв, цифр или символа
подчёркивания - то есть это "нестрогая" проверка, т.к. важна ключевая
последовательность `VERSION_TEXT`, а изменение префиксов и суффиксов не
окажет влияния). Эта строка разбивается на несколько фрагментов: 1) то,
что находится перед нужным идентификатором, 2) сам идентификатор, 3) оператор
присваивания, 4) старое значение и, иногда, 5) продолжение строки после
значения (в команде `set` всё после `=` является значением и (5) отсутствует).
После чего в выводимой строке заменяются идентификатор на новый (префикс
и/или суффикс могут быть изменены), значение заменяется новым, а начало
строки, средняя часть с оператором присваивания и продолжение строки
сохраняются.

Следует иметь в виду, что "$1" может быть как именем реального файла, так
и некоторым специальным значением:

- `//-` используется для обозначения штампа, выводимого на стандартный
  вывод, при этом для создания штампа вызывается `__PLUGIN_XXX_CREATE__`.

- `//--` указывает, что штамп был получен со стандартного ввода, изменён,
  и на стандартный вывод отправляется штамп после изменений, для чего
  должна была быть вызвана функция `__PLUGIN_XXX_MODIFY__`.

## Разработка собственных средств форматирования текста версии <a name="C5.2"/>

Обычное текстовое представление версии "v1.2.333-branchname" не является
единственно правильным и принято далеко не во всех случаях. Тот же
`git describe` представит версию в виде "v1.2-333-gHASHCODE", где не
только отсутствует обозначение ветки, но также уровень патча отделён от
старшего и младшего номеров дефисом. Подобных нюансов может быть великое
множество и в разных командах могут быть приняты самые разные варианты
тестового обозначения версии.

Данный version-stamper предлагает пару альтернативных способов формирования
текста версии, а также предоставляет возможность расширения этих возможностей,
с помощью вспомогательных скриптов. Такие скрипты должны соответствовать
шаблону имени `version-stamper-texturize-xxx`, а файл конфигурации проекта
`.version-stamper` выбирает нужный с помощью опции `textoize: xxx` (где
`xxx` — название варианта). Каждый скрипт прост и может быть записан в
одну строку:

```
VERSION_TEXT="${VERSION_PREFIX}${VERSION_MAJOR}.${VERSION_MINOR}${VERSION_SUFFIX}-${VERSION_BUILD}.${VERSION_TEXT}${VERSION_DIRTY}"
```

Скрипт должен присвоить желаемое значение переменной `VERSION_TEXT`,
используя для этого любые другие известные переменные `VERSION_xxx`, см.
раздел [Параметры version-stamper] (#C4.1). Также могут выполняться любые
модификации этих переменных, например, можно использовать специальный
скрипт `version-stamper-rename`, чтобы вместо `branchname` (иногда довольно
длинного) использовать более короткий вариант.

Например, `alt` вариант строки версии генерируется сценарием `version-stamper-textoize-alt`,
который состоит всего из трех исполняемых строк:

```
source ${STAMPER_SCRIPT_PATH}-rename
VERSION_TEXT="${VERSION_PREFIX}${VERSION_MAJOR}.${VERSION_MINOR}${VERSION_SUFFIX}-${VERSION_BUILD}.${VERSION_RENAMED}${VERSION_DIRTY}"
unset VERSION_RENAMED
```

Первая строка подключает скрипт `version-stamper-rename` (обратите внимание:
конструкция `${STAMPER_SCRIPT_PATH}-rename` используется для того, чтобы
можно было легко переименовывать файлы version-stamper), который присваивает
переменной `VERSION_RENAMED` "улучшенный" вариант `VERSION_BRANCH`. Вторая
строка формирует текстовое представление и последняя уничтожает временную
переменную `VERSION_RENAMED`.

## Тестирование <a name="C5.3"/>

Система тестов разрабатывается и пополняется в отдельной ветке `tests`.
Общая идея в том, чтобы всё, относящееся к тестам, сосредоточить
в папке `./tests/`, которая исключена из репозитория (см. `.gitignore`).
Таким образом, при простом клонировании version-stamper в свой проект
ничего лишнего сверх необходимого рабочего кода version-stamper не будет
клонироваться.

Однако, если потребуется отладка, или вы будете разрабатывать свои плагины,
то имеет смысл подключить юнит-тесты к текущей ветке. Для этого надо
добавить в папку `./tests` все файлы, содержащиеся в ветке `tests`. Сделать
это можно командой

```
./tools/stamper> git worktree add ./tests tests
```

# Приложения <a name="C6"/>

## Общие проблемы Windows <a name="C6.1"/>

Самая основная проблема, чаще других приводящая к сбоям - наличие нескольких
разных и иногда плохо несовместимых между собой реализаций posix-совместимой
среды. Чаще всего в Windows применяется т.н. `git-for-windows`, построенный
на основе проекта `MSYS2` (бывший `mingw`), но также могут использоваться
собственные экземпляры `MSYS2` или `Cygwin`, а в достаточно старых системах
могут даже обнаружится `SFU` или `SUA` от Microsoft.

Часто бывает так, что какую-то среду, иногда сильно урезанную, приносят с
собой средства разработки. Это, скажем, достаточно характерно для средств
разработки ПО микроконтроллеров, когда какой-то урезанный вариант среды
приходит вместе с тулчейном.

Если вся работа выполняется в одной такой среде, то сложностей обычно не
возникает, но во многих таких средах отсутствуют либо нужные инструменты
разработки (которых, к примеру, нет в `git-for-windows`), либо отсутствует
собственно `git`. А в результате возникает ситуация, когда из одной
posix-совместимой среды выполняются утилиты другой и такой переход может
выполняться многократно в одной задаче.

Например - средства сборки проекта, принадлежащие какой-то своей среде,
выполняют команду `git`, имеющейся в `git-for-windows`, а в процессе
создания коммита выполняется перехватчик `pre-commit`, который в свою
очередь выполнит команду из какой-то третьей среды... и так далее.

Наиболее характерные причины проблем рассмотрены ниже.

### Разные корни файловых систем <a name="C6.1.1"/>

Разные среды размещены в разных каталогах и имеют разные "корневые
файловые системы" и, соответственно, разные пути к файлам проекта.
К примеру, в `MSYS2` (и в `git`) путь к папке на диске `C:` может
выглядеть как `/c/users/person/project/file.c`, а в `cygwin` он уже
будет представлен как `/cygdrive/c/users/person/project/file.c`.
Соответственно, попытка выполнить нечто вроде:

```
$ git add /cygdrive/c/users/person/project/file.c
```

Приведёт к ошибке, так как такой путь к файлу в `git` не поддерживается.

Для решения можно предложить пару вариантов:

- проще всего использовать "смешанный" способ представления имён файлов,
  то есть в виде `c:/users/person/project/file.c` - почти как в Windows,
  но разделителем является прямая косая вместо обратной. Программы в
  Posix-совместимых средах обычно понимают такой способ, и даже некоторые
  Windows программы - тоже (чаще всего при передаче аргументов приложениям
  Windows путь всё-таки надо будет  преобразовать).

- иногда возможны трюки, позволяющие из одной среды иметь доступ по пути в
  другой среде. Например, "подружить" `git-for-windows` с `cygwin` (но
  не наоборот) можно, создав с корневой системе `git` папку `cygdrive`
  и разместив там ссылки на корни дисков Windows. Делать это надо с правами
  администратора Windows, например, так (команды `cmd.exe`):

```
	c:\temp> cd "C:\Program Files\Git"
	C:\Program Files\Git> mkdir cygdrive
	C:\Program Files\Git> cd cygdrive
	C:\Program Files\Git\cygdrive> mklink /J c c:\
	C:\Program Files\Git\cygdrive> mklink /J d d:\
	C:\Program Files\Git\cygdrive> mklink /J e e:\
	...
```

  В результате в `git` станут возможны пути вида `/cygdrive/d/my/folder`
  и т.п.

### Отсутствие символьных ссылок <a name="C6.1.2"/>

Самое нелепое, что в Windows как раз существуют аналоги ссылок, как
символьных, так и жёстких, но вот posix-совместимые среды обычно их не
реализуют, либо реализуют своими внутренними способами.

В первом случае команда `ln ...` может приводить к копированию файла ...
и даже каталога. Скажем, попытка выполнить что-то вроде `ln foo /` в
`git-for-windows` (то есть `MSYS2`) приведёт к копированию в папку `foo`
содержимого всего диска `C:` - а если папка `foo` также находится на `C:`,
то к ошибке чересчур глубокой рекурсии ... но в обоих вариантах это не то,
что вы хотели.

Во втором случае проблемы возникнут при использовании этой ссылки в другой
среде или в Windows-программе.

Если нужны символьные ссылки на каталоги, то можно использовать аналог
символьных ссылок в Windows - т.н. "junction". Для создания такой ссылки
предназначена команда:

```
   C:\temp> mklink /J link_name c:\users\person\folder
```

В теории эта же команда может создавать "настоящие" символьные ссылки как
на файлы, так и на каталоги и даже жёсткие ссылки .. но почему-то для
этого надо быть администраторам. А для рядового пользователя доступны лишь
"junction".

### Режим доступа к файлам и папкам <a name="C6.1.3"/>

Эта возможность также сильно ограничена в некоторых posix-совместимых
средах, либо реализована достаточно грубо.

В `MSYS2` (и в `git-for-windows`) команда `chmod ...` обычно ни на что не
влияет; а попытка с её помощью назначить право выполнения файла будет
проигнорирована.

В `MSYS2` биты права выполнения проставляются автоматически
исходя из типа файла (расширения имени, скажем, все `.exe`, `.bat` и т.п.
файлы будут считаться исполняемыми) и его содержимого - если вам надо
сделать исполняемый скрипт, то в первой строке скрипта должна быть
ссылка на исполняемый интерпретатор, то есть что-то вида

```
#!/bin/bash
```

в первой строке текстового файла приведёт к тому, что биты разрешения
исполнения будут выставлены в 1, если указанный `/bin/bash` существует
и является исполняемым.

В `cygwin` и в `SFU/SUA` эта команда реализована и работает. Но важно,
что некоторые комбинации прав в unix-стиле (`rwxrwxrwx`) корректно не
реализуются в Windows вообще, равно как справедливо обратное - невозможно
корректно отобразить реализуемые в Windows комбинации прав доступа на
9 флагов unix.

В `SFU/SUA` команда `chmod ...` работает "не всегда", ограничиваясь лишь
допустимыми комбинациями прав доступа, то в `cygwin` она реализует любую
запрошенную комбинацию, но ценой нарушения правил (по нормам Microsoft
списки прав доступа, т.н. "ACL" должны быть упорядочены - сначала запреты,
потом разрешения). В итоге в `cygwin` попытка изменить права доступа
приводит и к отмене всех унаследованных прав от контейнеров и к получению
неправильно упорядоченного набора ACL, что в некоторых случаях обнаруживается
утилитами проверки диска в Windows и сходными инструментами. Излишне
говорить, что исправление этой "ошибки" таким инструментом приведёт к
нарушению ранее назначенных прав и, весьма вероятно, к тому, что что-то
перестанет работать.

## Немного о перехватчиках git (git hooks) <a name="C6.2"/>

Ниже приводятся некоторые типичные последовательности выполнения
перехватчиков git. Не следует рассматривать эти последовательности в
качестве строгого руководства - они были получены экспериментально и
в реальности могут видоизменяться в зависимости от фактической ситуации
(пустой репозиторий вообще без коммитов, репозиторий с историей и с чистым
рабочим деревом, репозиторий с локальными или подготовленными изменениями
и т.д. и т.п.).

*Примечания:* слово `old` обозначает самый "верхний" коммит в истории,
`new` - новый коммит, создаваемый данной операцией. Иногда используется
`new temp` - что обозначает новый промежуточный коммит, создаваемый для
последовательного применения изменений. Термин `distance` следует понимать
как некоторый "номер коммита" или номер сборки, возвращаемый командой
`git describe`. Можно рассматривать как условное "расстояние" от текущего
коммита до некоторого коммита в прошлом, возможно до начального коммита.

**Обычный** коммит:

```
pre-commit  ->  prepare-commit-msg  ->  commit-msg  ->  post-commit
<---------------- o l d   c o m m i t ----------------><-- n e w -->
                                                       (distance increased)
```
                                                           
**Замещающий** коммит (**amend**):

```
pre-commit  ->  prepare-commit-msg  ->  commit-msg  ->  post-commit  ->  post-rewrite amend
<---------------- o l d   c o m m i t ----------------><------- n e w   c o m m i t ------->
                                                        (distance not changed)
```

**Объединение** нескольких коммитов (**squash**):<br/>
Объединение нескольких коммитов делается в цикле, в котором каждый новый
объединяемый коммит применяется к промежуточному, суммируя таким образом
все изменения в этом промежуточном коммите. Финальное состояние
промежуточного коммита соответствует желаемому результату. Однако, если
в процессе такого слияния возникает сбой (что может быть спровоцировано
перехватчиком), то вся последовательность может быть отменена.

```
pre-rebase  ->  post-checkout  ->  (  prepare-commit-msg  ->  post-commit  ->  post-rewrite amend  ) ->  post-rewrite rebase
<-- o l d --><-- f i r s t -->        <----- p r e v -----><--- n e w   t e m p   c o m m i t ---><--- l a s t   c o m m i t --->
            (distance reduced here)  -------------------------------------------------------->    (distance remains reduced)
            (HEAD detached)                               (detached HEAD is promoted to temp commit)     (HEAD attached to branch)
                                    (ORIG_HEAD:old_sha)
                                    (AUTO_MERGE:other_sha)
```

Цикл, выполняемый для каждого коммита в объединении, вызывает перехватчики
( prepare-commit-msg  ->  post-commit  ->  post-rewrite amend ). В течении
этого цикла ORIG_HEAD не изменяется. MERGE_MSG содержит текст сообщения
добавляемого коммита, а в COMMIT_EDITMSG накапливаются все сообщения.

В последней итерации цикла накопленное COMMIT_EDITMSG копируется в
SQUASH_MSG во время prepare-commit-msg, после чего воссоздаётся
COMMIT_EDITMSG из SQUASH_MSG и дополнительного текста. Также добавляется
REBASE_HEAD соответствующий ORIG_HEAD наначало всей операции.

Ко времени post-commit файл COMMIT_MSG скопирован в сообщение нового
коммита, SQUASH_MSG и AUTO_MERGE удалены.

**Слияние** (**merge**); проверено лишь частично, слишком много стратегий
и способов слияния, в т.ч. слияния более чем двух ветвей сразу (octopus).

```
prepare-commit-msg  ->  commit-msg  ->  post-merge 0
<------- o l d   c o m m i t --------><--- n e w --->
                                      (distance increased by count of new commits on all ways)
(MERGE_HEAD - one or few SHAs to merge, one per line)
(ORIG_HEAD)
(MERGE_MODE - this is not strategy name, this is strategy options)
(MERGE_MSG)
```

## Обзор структуры каталогов репозитория git <a name="C6.3"/>

В модельном случае предполагаем, что у нас есть репозиторий git в каталоге
`./MAIN`, в этом репозитории имеется подмодуль `SUBMODULE` (путь к каталогу
`./MAIN/SUBODULE`) и дополнительно у репозитория имеется дополнительное
рабочее дерево `./WORKTREE`, при этом подмодуль присутствует также и в той
ветке, на которую настроено рабочее дерево `WORKTREE`.

**Подмодуль** характеризуется локальным путём в дереве (в нашем примере
каталог `SUBMODULE` находится прямо в корне репозитория), источником
(удалённым репозиторием) и необязательной веткой. Ветка, если указана,
просто задаёт начальное состояние подмодуля; независимо от того, указана
она или нет подмодуль приводится в состояние *detached head*, а переключить
его в присоединённое состояние можно только вручную.

Путь подмодуля используется в роли "идентификатора" - информация о подмодуле
будет сохраняться внутри папки репозитория `.git/modules/` с таким же
относительным путём, как он расположен в рабочем дереве.

**Рабочее дерево** характеризуется путём, где оно находится (вне основного
рабочего дерева), назначенным именем этого дерева и веткой, которой дерево
соответствует. При этом у конкретной ветки не может быть более одного
рабочего дерева.

Назначенное имя рабочего дерева используется для его идентификации в
иерархии `.git/worktrees/`.

```
папка   ./MAIN                  << каталог с рабочим деревом (суперпроект) и папкой .git.
папка   .   ./SUBMODULE         << подмодуль проекта, вместо вложенной папки .git содержит
        .   .                      файл с ссылкой на нужный подкаталог в .git суперпроекта.
 файл   .   .   .git            << содержит относительный путь к папке репозитория
        .   .   .                  (здесь "gitdir: ../.git/modules/SUBMODULE").
 файл   .   .gitmodules         << файл суперпроекта, описывающий входящие в него подмодули
        .   .                      (имя, адрес источника, локальный путь, ветка (если есть))
        .   .                      в виде файла конфигурации - можно читать git config ...
папка   .   ./.git              << подкаталог .git с данными репозитория суперпроекта и
        .   .   .                  вложенными в него данными подмодулей и сведениями о
        .   .   .                  связанных рабочих деревьях.
 файл   .   .   HEAD            << ссылка на ветку (в виде ref: refs/heads/master 
        .   .   .                  или хеш коммита для detached head).
 файл   .   .   config          << конфигурация суперпроекта (про подмодули есть
        .   .   .                  свои секции с адресом источника и флагом активности,
        .   .   .                  а про поддеревья ни слова).
 файл   .   .   description     << обычно не используется, описание репозитория.
 файл   .   .   packed-refs     << список ссылок на коммиты в упакованных наборах.
папка   .   .   ./branches      << обычно пустая папка.
папка   .   .   ./hooks         << набор перехватчиков репозитория (данного репозитория
        .   .   .                  и связанных рабочих деревьев, но не подмодулей).
папка   .   .   ./info          << обычно не используется.
папка   .   .   ./logs          << каталог с файлами, содержащими историю перемещения
        .   .   .                  указателей веток.
папка   .   .   ./modules       << папка, содержащая сведения о подмодулях (может отсутствовать).
папка   .   .   .   ./SUBMODULE         << "идентификатор" подмодуля - такой же относительный путь.
        .   .   .   .   .                  как в рабочем каталоге.
 файл   .   .   .   .   HEAD            << ссылка на ветку подмодуля.
 файл   .   .   .   .   config          << конфигурация подмодуля.
 файл   .   .   .   .   description     << описание подмодуля (обычно не используется).
 файл   .   .   .   .   packed-refs     << список ссылок на коммиты в упакованных наборах.
папка   .   .   .   .   ./branches      << обычно пустая папка.
папка   .   .   .   .   ./hooks         << перехватчики git подмодуля.
папка   .   .   .   .   ./info          << обычно не используется.
папка   .   .   .   .   ./logs          << каталог с файлами, содержащими историю.
        .   .   .   .   .   ...
папка   .   .   .   .   ./objects       << каталог с объектами репозитория подмодуля.
папка   .   .   .   .   ./refs          << каталог с ссылками (ветки, тэги) подмодуля.
папка   .   .   .   .   .   ./heads         << каталог с локальными ветками подмодуля.
 файл   .   .   .   .   .   .   master      << файл с хэшем коммита ветки подмодуля.
папка   .   .   .   .   .   ./remotes       << каталог с удалёнными репозиториями подмодуля.
папка   .   .   .   .   .   .   ./origin    << каталог для origin подмодуля.
 файл   .   .   .   .   .   .   .   master  << файл с хэшем коммита ветки удалённого репозитория.
папка   .   .   .   .   .   ./tags          << каталог с тэгами подмодуля.
 файл   .   .   .   .   .   .   v0.0        << файл с хэшем коммита тэга подмодуля.
папка   .   .   ./objects       << каталог с объектами репозитория суперпроекта.
папка   .   .   .   ./00        << каталог для объектов, хэш которых начинается с 00.
папки   .   .   .   .   ...
папка   .   .   .   ./FF        << каталог для объектов, хэш которых начинается с FF.
папка   .   .   .   ./info
папка   .   .   .   ./pack      << каталог для упакованных наборов объектов.
папка   .   .   ./refs          << каталог с ссылками (ветки, тэги) суперпроекта.
папка   .   .   .   ./heads         << каталог с локальными ветками суперпроекта.
 файл   .   .   .   .   master      << файл с хэшем коммита ветки суперпроекта.
папка   .   .   .   ./remotes       << каталог с удалёнными репозиториями суперпроекта.
папка   .   .   .   .   ./origin    << каталог для origin суперпроекта.
 файл   .   .   .   .   .   master  << файл с хэшем коммита ветки удалённого репозитория.
папка   .   .   .   ./tags          << каталог с тэгами суперпроекта.
 файл   .   .   .   .   v0.0        << файл с хэшем коммита тэга суперпроекта.
папка   .   .   ./worktrees     << папка, содержащая сведения о связанных рабочих деревьях (может отсутствовать).
папка   .   .   .   ./worktree-name << папка с именем, назначенным связанному рабочему дереву.
 файл   .   .   .   .   HEAD        << ссылка на ветку, сопоставленную с рабочим деревом.
 файл   .   .   .   .   commondir   << относительный путь к MAIN/.git (здесь "../.." фактически укажет
        .   .   .   .   .               на ./MAIN/.git), никаких префиксов типа "gitdir: " нет.
 файл   .   .   .   .   gitdir      << абсолютный путь к файлу .git рабочего дерева (здесь "*/WORKTREE/.git"),
        .   .   .   .   .               никаких префиксов типа "gitdir: " нет.
папка   .   .   .   .   ./logs      << каталог с файлами, содержащими историю.
папка   .   .   .   .   ./modules   << папка, содержащая сведения о подмодулях (может отсутствовать).
папка   .   .   .   .   .   ./SUBMODULE << папка, описывающая подмодуль связанного рабочего дерева
        .   .   .   .   .   .              (т.е. WORKTREE/SUBMODULE). Это дубликат папки из основного
        .   .   .   .   .   .              дерева ./MAIN/.git/modules/SUBMODULE.
папка   ./WORKTREE              << связанное рабочее дерево, обрабатывается также, как репозиторий
        .   .                      с отделённым каталогом .git (git clone --separate-git-dir ...).
 файл   .   .git                << содержит абсолютный путь к папке репозитория
        .   .                      (здесь "gitdir: */MAIN/.git/worktrees/worktree-name").
папка   .   ./SUBMODULE         << рабочий каталог подмодуля.
 файл   .   .   .git            << содержит абсолютный путь к папке репозитория
        .   .   .                  (здесь "gitdir: */MAIN/.git/worktrees/worktree-name/modules/SUBMODULE")
```
